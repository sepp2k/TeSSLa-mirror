module Predef {
  def nil[T]: Events[T] = __builtin__(nil)
  def default[T](stream: Events[T], value: T): Events[T] = __builtin__(default)
  def first[T, U](stream1: Events[T], stream2: Events[U]): Events[T] = slift(stream1, stream2, (x: T, _: U) => x)
  def fold[T,R](stream: Events[T], init: R, f: (Events[R],Events[T]) => Events[R]) = result where {
    def result: Events[R] = default(f(last(result, stream), stream), init)
  }
}

#module Predef {
  # Fundamental types

  ## A Boolean can be either [`true`](#true) or [`false`](#false)
  type Bool = __builtin__(Bool)

  ## Integer. The maximal and minimal values depend on the TeSSLa engine. The TeSSLa software backend uses
  ## [BigInt](https://www.scala-lang.org/api/2.12.7/scala/math/BigInt$.html), i.e. every integer can be represented
  type Int = __builtin__(Int)

  ## Float. The data range depends on the TeSSLa engine. The TeSSLa software backend uses a 64-bit IEEE-754 floating
  ## point number
  type Float = __builtin__(Float)

  ## String can store arbitrary long character sequences
  type String = __builtin__(String)

  ## `()` is the only value of type `Unit`, i.e. this type can be used to represent events without values.
  type Unit = ()

  ## Basic type for streams
  type Events[T] = __builtin__(Events)

  ## Functions annotated with this annotation can be used on streams which will be equivalent to wrapping their call
  ## with `slift`.
  def @liftable

  # Primitive constants and operators

  ## A Boolean value representing that a given proposition is true
  def true: Bool = __builtin__(true)

  ## A Boolean value representing that a given proposition is false
  def false: Bool = __builtin__(false)

  ## **Operator usage:** `!x`
  ##
  ## Boolean complement
  @liftable
  def __not__(arg: Bool): Bool = __builtin__(__not__)

  ## **Operator usage:** `if c then a else b`
  ##
  ## If-Then-Else
  @liftable
  def __ite__[T](cond: Bool, thenCase: T, elseCase: T): T = __builtin__(__ite__)

  ## **Operator usage:** `a && b`
  ##
  ## Boolean conjunction
  @liftable
  def __and__(lhs: Bool, rhs: Bool): Bool = __builtin__(__and__)

  ## **Operator usage:** `a || b`
  ##
  ## Boolean disjunction
  @liftable
  def __or__(lhs: Bool, rhs: Bool): Bool = __builtin__(__or__)

  ## **Operator usage:** `a == b`
  ##
  ## Equivalence on arbitrary data types. On complex data structures this operator checks the object's identity. Note,
  ## that this operator is defined as `@liftable`, so it does neither check the equivalence nor the identity of streams,
  ## but applies the operator on two streams using the signal semantics.
  @liftable
  def __eq__[T](lhs: T, rhs: T): Bool = __builtin__(__eq__)

  ## **Operator usage:** `a != b`
  ##
  ## Non-Equivalence on arbitrary data types. On complex data structures this operator checks the object's identity. Note,
  ## that this operator is defined as `@liftable`, so it does neither check the equivalence nor the identity of streams,
  ## but applies the operator on two streams using the signal semantics.
  @liftable
  def __neq__[T](lhs: T, rhs: T): Bool = __builtin__(__neq__)

  ## **Operator usage:** `a > b`
  ##
  ## Returns [`true`](#true) if `a` is strictly greater than `b`
  @liftable
  def __gt__(lhs: Int, rhs: Int): Bool = __builtin__(__gt__)

  ## **Operator usage:** `a < b`
  ##
  ## Returns [`true`](#true) if `a` is strictly lower than `b`
  @liftable
  def __lt__(lhs: Int, rhs: Int): Bool = __builtin__(__lt__)

  ## **Operator usage:** `a >= b`
  ##
  ## Returns [`true`](#true) if `a` is greater than or equal to `b`
  @liftable
  def __geq__(lhs: Int, rhs: Int): Bool = __builtin__(__geq__)

  ## **Operator usage:** `a <= b`
  ##
  ## Returns [`true`](#true) if `a` is lower than or equal to `b`
  @liftable
  def __leq__(lhs: Int, rhs: Int): Bool = __builtin__(__leq__)

  ## **Operator usage:** `a >. b`
  ##
  ## Returns [`true`](#true) if `a` is strictly greater than `b`
  @liftable
  def __fgt__(lhs: Float, rhs: Float): Bool = __builtin__(__fgt__)

  ## **Operator usage:** `a <. b`
  ##
  ## Returns [`true`](#true) if `a` is strictly lower than `b`
  @liftable
  def __flt__(lhs: Float, rhs: Float): Bool = __builtin__(__flt__)

  ## **Operator usage:** `a >=. b`
  ##
  ## Returns [`true`](#true) if `a` is greater than or equal to `b`
  @liftable
  def __fgeq__(lhs: Float, rhs: Float): Bool = __builtin__(__fgeq__)

  ## **Operator usage:** `a <=. b`
  ##
  ## Returns [`true`](#true) if `a` is lower than or equal to `b`
  @liftable
  def __fleq__(lhs: Float, rhs: Float): Bool = __builtin__(__fleq__)

  ## **Operator usage:** `a + b`
  ##
  ## Returns the sum of two integers
  @liftable
  def __add__(lhs: Int, rhs: Int): Int = __builtin__(__add__)

  ## **Operator usage:** `a - b`
  ##
  ## Returns the difference of two integers
  @liftable
  def __sub__(lhs: Int, rhs: Int): Int = __builtin__(__sub__)

  ## **Operator usage:** `a * b`
  ##
  ## Returns the multiplication of two integers
  @liftable
  def __mul__(lhs: Int, rhs: Int): Int = __builtin__(__mul__)

  ## **Operator usage:** `a / b`
  ##
  ## Returns the division of two integers
  @liftable
  def __div__(lhs: Int, rhs: Int): Int = __builtin__(__div__)

  ## **Operator usage:** `a % b`
  ##
  ## Returns the remainder of two integers
  @liftable
  def __mod__(lhs: Int, rhs: Int): Int = __builtin__(__mod__)

  ## **Operator usage:** `-a`
  ##
  ## Unary minus on integers
  @liftable
  def __negate__(arg: Int): Int = __builtin__(__negate__)

  ## **Operator usage:** `a & b`
  ##
  ## Bitwise AND on integers
  @liftable
  def __bitand__(lhs: Int, rhs: Int): Int = __builtin__(__bitand__)

  ## **Operator usage:** `a | b`
  ##
  ## Bitwise OR on integers
  @liftable
  def __bitor__(lhs: Int, rhs: Int): Int = __builtin__(__bitor__)

  ## **Operator usage:** `a ^ b`
  ##
  ## Bitwise XOR on integers
  @liftable
  def __bitxor__(lhs: Int, rhs: Int): Int = __builtin__(__bitxor__)

  ## **Operator usage:** `~a`
  ##
  ## Bitflip on integers
  @liftable
  def __bitflip__(arg: Int): Int = __builtin__(__bitflip__)

  ## **Operator usage:** `a << b`
  ##
  ## Arithmetic left shift on integers
  @liftable
  def __leftshift__(lhs: Int, rhs: Int): Int = __builtin__(__leftshift__)

  ## **Operator usage:** `a >> b`
  ##
  ## Arithmetic right shift on integers
  @liftable
  def __rightshift__(lhs: Int, rhs: Int): Int = __builtin__(__rightshift__)

  ## **Operator usage:** `a +. b`
  ##
  ## Returns the sum of two floats
  @liftable
  def __fadd__(lhs: Float, rhs: Float): Float = __builtin__(__fadd__)

  ## **Operator usage:** `a -. b`
  ##
  ## Returns the difference of two floats
  @liftable
  def __fsub__(lhs: Float, rhs: Float): Float = __builtin__(__fsub__)

  ## **Operator usage:** `a *. b`
  ##
  ## Returns the multiplication of two floats
  @liftable
  def __fmul__(lhs: Float, rhs: Float): Float = __builtin__(__fmul__)

  ## **Operator usage:** `a /. b`
  ##
  ## Returns the division of two floats
  @liftable
  def __fdiv__(lhs: Float, rhs: Float): Float = __builtin__(__fdiv__)

  ## **Operator usage:** `-.a`
  ##
  ## Unary minus on floats
  @liftable
  def __fnegate__(arg: Float): Float = __builtin__(__fnegate__)

  # Functions for primitive types

  ## Converts any type into its typical string representation
  @liftable
  def toString[T](arg: T): String = __builtin__(toString)

  ## Returns the value of the first argument raised to the power of the second argument.
  @liftable
  def pow(base: Float, exponent: Float): Float = __builtin__(pow)

  ## Returns the logarithm to base `base` of `x`
  @liftable
  def log(x: Float, base: Float): Float = __builtin__(log)

  ## Returns the trigonometric sine of an angle `x` in radians. Special cases:
  ##
  ## * If the argument is NaN or an infinity, then the result is NaN.
  ## * If the argument is zero, then the result is a zero with the same sign as the argument.
  @liftable
  def sin(x: Float): Float = __builtin__(sin)

  ## Returns the trigonometric cosine of an angle in radians. Special cases:
  ##
  ## * If the argument is NaN or an infinity, then the result is NaN.
  @liftable
  def cos(x: Float): Float = __builtin__(cos)

  ## Returns the trigonometric tangent of an angle in radians. Special cases:
  ##
  ## * If the argument is NaN or an infinity, then the result is NaN.
  ## * If the argument is zero, then the result is a zero with the same sign as the argument.
  @liftable
  def tan(x: Float): Float = __builtin__(tan)

  ## Returns the arc tangent of a value; the returned angle is in the range _-π/2_ through _π/2_. Special cases:
  ##
  ## * If the argument is NaN, then the result is NaN.
  ## * If the argument is zero, then the result is a zero with the same sign as the argument.
  @liftable
  def atan(x: Float): Float = __builtin__(atan)

  ## Converts the given integer to a float.
  @liftable
  def intToFloat(x: Int): Float = __builtin__(intToFloat)

  ## Converts the given float to an integer without
  @liftable
  def floatToInt(x: Float): Int = __builtin__(floatToInt)

  # Predef option functionality
  # Note that the core of the option functionality is defined here because options are fundamental
  # enough (lift etc. make use of options) that having the functions in Predef makes sense.
  # Further functionality (such as map etc.) will be defined in the Option module

  ## Represents optional values. Instances of `Option` are either an instance of [`Some`](#some) or [`None`](#none)
  type Option[T] = __builtin__(Option)

  ## Represents non-existent values of type `T`
  def None[T]: Option[T] = __builtin__(None)

  ## Represents existing values of type `T`
  @liftable
  def Some[T](value: T): Option[T] = __builtin__(Some)

  ## Returns [`true`](#true) if the given option is a [`None`](#none) or [`false`](#false) if it is a [`Some`](#some)
  @liftable
  def isNone[T](opt: Option[T]): Bool = __builtin__(isNone)

  ## Returns [`true`](#true) if the given option is a [`Some`](#some) or [`false`](#false) if it is a [`None`](#none)
  @liftable
  def isSome[T](opt: Option[T]): Bool = !isNone(opt)

  ## Get the value contained in a [`Some`](#some). If the given option is a [`None`](#none), a run-time error will occur
  @liftable
  def getSome[T](opt: Option[T]): T = __builtin__(getSome)

  ## Get the value contained in a [`Some`](#some). If the given option is a [`None`](#none), the default value `value` will be returned
  @liftable
  def getSomeOrElse[T](opt: Option[T], value: T): T = if isSome(opt) then getSome(opt) else value

  # Built-in stream functions

  ## Returns an empty stream without any event of type `T`
  def nil[T]: Events[T] = __builtin__(nil)

  ## Returns a stream which contains all the events of the given `stream`. If `stream` has no event at
  ## timestamp 0, then an additional event with value `value` is added at timestamp 0.
  ##
  ## **Usage example:**
  ##
  ## ~~~ruby
  ## in a: Events[Int]
  ## def d = default(a, 42)
  ## out d
  ## ~~~
  ##
  ## **Trace example:**
  ##
  ## ~~~trace
  ## option timeDomain: [-0.1,6]
  ## stream a: bubbles
  ## stream d: bubbles
  ## ---
  ## 0: d = 42
  ## 2: a = 17
  ## 2: d = 17
  ## 5: a = 23
  ## 5: d = 23
  ## ~~~
  ##
  ## **Alternative trace example:**
  ##
  ## ~~~trace
  ## option timeDomain: [-0.1,6]
  ## stream a: bubbles
  ## stream d: bubbles
  ## ---
  ## 0: a = 12
  ## 0: d = 12
  ## 2: a = 17
  ## 2: d = 17
  ## 5: a = 23
  ## 5: d = 23
  ## ~~~
  ##
  def default[T](stream: Events[T], value: T): Events[T] = __builtin__(default)

  ## Similar to [`default`](#default), this operation returns a stream which contains
  ## all the events of the given `valueStream`. If the first event on `defaultStream` happens
  ## strictly before the first event on `valueStream` then this event is added. No events other
  ## than the first event on `defaultStream` are considered.
  ##
  ## **Usage example:**
  ##
  ## ~~~ruby
  ## in v: Events[Int]
  ## in x: Events[Int]
  ## def d = defaultFrom(v, x)
  ## out d
  ## ~~~
  ##
  ## **Trace example:**
  ##
  ## ~~~trace
  ## stream v: bubbles
  ## stream x: bubbles
  ## stream d: bubbles
  ## ---
  ## 2: x = 5
  ## 2: d = 5
  ## 3: x = 3
  ## 3: d = 2
  ## 3: v = 2
  ## 5: x = 7
  ## 6: d = 4
  ## 6: v = 4
  ## ~~~
  ##
  ## **Alternative trace example:**
  ##
  ## ~~~trace
  ## stream v: bubbles
  ## stream x: bubbles
  ## stream d: bubbles
  ## ---
  ## 1: d = 6
  ## 1: v = 6
  ## 2: x = 5
  ## 3: x = 3
  ## 3: d = 2
  ## 3: v = 2
  ## 5: x = 7
  ## 6: d = 4
  ## 6: v = 4
  ## ~~~
  def defaultFrom[T](valueStream: Events[T], defaultStream: Events[T]): Events[T] = __builtin__(defaultFrom)

  ## Lifts a function `f` which is defined on values to a function on streams and applies it to the
  ## given streams. The function `f` is called for every event on any of the streams. If there is a
  ## simultaneous event on the other stream, then the values of both events are passed to `f`. Otherwise
  ## the other argument is `None` if there is no simultaneous event on the other stream. `f` is never
  ## called with all arguments being `None`.
  ##
  ## **Usage example:**
  ##
  ## ~~~ruby
  ## in a: Events[Int]
  ## in b: Events[Int]
  ## def f(a: Option[Int], b: Option[Int]) =
  ##   if isSome(a) && getSome(a) > 5 then a else b
  ## def c = lift(a,b,f)
  ## out c
  ## ~~~
  ##
  ## **Trace example:**
  ##
  ## ~~~trace
  ## stream a: bubbles
  ## stream b: bubbles
  ## stream c: bubbles
  ## ---
  ## 1: c = 7
  ## 1: a = 7
  ## 2: a = 5
  ## 3: b = 6
  ## 3: c = 6
  ## 4: b = 2
  ## 4: c = 2
  ## 4: a = 3
  ## 5: b = 4
  ## 5: c = 9
  ## 5: a = 9
  ## ~~~
  def lift[T, U, V](stream1: Events[T], stream2: Events[U], f: (Option[T], Option[U]) => Option[V]): Events[V] = __builtin__(lift)

  ## Lifts a unary function `f` which is defined on values to a function on a stream and applies it to the
  ## given stream. The function `f` is called for every event on the streams. Because there is no
  ## other stream, the argument of `f` will never be `None`. (`f` is never
  ## called with all arguments being `None`.)
  ##
  ## **Usage example:**
  ##
  ## ~~~ruby
  ## in a: Events[Int]
  ## def f(a: Option[Int]) =
  ##   if getSome(a) > 5 then a else None[Int]
  ## def b = lift1(a,f)
  ## out b
  ## ~~~
  ##
  ## **Trace example:**
  ##
  ## ~~~trace
  ## stream a: bubbles
  ## stream b: bubbles
  ## ---
  ## 1: b = 7
  ## 1: a = 7
  ## 2: a = 5
  ## 4: a = 3
  ## 5: b = 9
  ## 5: a = 9
  ## ~~~
  def lift1[T, U](stream: Events[T], f: (Option[T]) => Option[U]): Events[U] =
    lift(stream, nil[Unit], (x: Option[T], dontCare: Option[Unit]) => f(x))

  ## Lifts a function `f` which is defined on values to a function on streams and applies it to the
  ## given streams. The function `f` is called for every event on any of the streams. If there is a
  ## simultaneous event on the other stream, then the values of both events are passed to `f`. Otherwise
  ## the other argument is `None` if there is no simultaneous event on the other stream. `f` is never
  ## called with all arguments being `None`.
  ##
  ## **Usage example:**
  ##
  ## ~~~ruby
  ## in a: Events[Int]
  ## in b: Events[Int]
  ## in c: Events[Int]
  ## def f(a: Option[Int], b: Option[Int], c: Option[Int]) =
  ##   if isSome(a) && getSome(a) > 5 then a
  ##   else if isSome(b) then b else c
  ## def d = lift3(a,b,c,f)
  ## out d
  ## ~~~
  ##
  ## **Trace example:**
  ##
  ## ~~~trace
  ## stream a: bubbles
  ## stream b: bubbles
  ## stream c: bubbles
  ## stream d: bubbles
  ## ---
  ## 1: d = 7
  ## 1: a = 7
  ## 2: a = 5
  ## 3: b = 6
  ## 3: d = 6
  ## 4: b = 2
  ## 4: d = 2
  ## 4: a = 3
  ## 5: c = 1
  ## 5: d = 1
  ## 6: b = 4
  ## 6: c = 3
  ## 6: d = 9
  ## 6: a = 9
  ## ~~~
  def lift3[T1, T2, T3, T4](stream1: Events[T1], stream2: Events[T2], stream3: Events[T3],
                            f: (Option[T1], Option[T2], Option[T3]) => Option[T4]): Events[T4] = {
    def stream2and3 = lift(stream2, stream3, (x: Option[T2], y: Option[T3]) => Some((x, y)))
    lift(stream1, stream2and3, (v1: Option[T1], v2and3opt: Option[(Option[T2], Option[T3])]) =>
      if isNone(v2and3opt)
      then f(v1, None[T2], None[T3])
      else {
        def v2and3 = getSome(v2and3opt)
        f(v1, v2and3._1, v2and3._2)
      })
  }

  ## Lifts a function `f` which is defined on values to a function on streams and applies it to the
  ## given streams. The function `f` is called for every event on any of the streams. If there is a
  ## simultaneous event on the other stream, then the values of both events are passed to `f`. Otherwise
  ## the other argument is `None` if there is no simultaneous event on the other stream. `f` is never
  ## called with all arguments being `None`.
  ##
  ## **Usage example:**
  ##
  ## ~~~ruby
  ## in a: Events[Int]
  ## in b: Events[Int]
  ## in c: Events[Int]
  ## in d: Events[Int]
  ## def f(a: Option[Int], b: Option[Int], c: Option[Int], d: Option[Int]) =
  ##   if isSome(a) && getSome(a) > 5 then a
  ##   else if isSome(b) then b
  ##   else if isSome(c) then c
  ##   else d
  ## def e = lift4(a,b,c,d,f)
  ## out e
  ## ~~~
  ##
  ## **Trace example:**
  ##
  ## ~~~trace
  ## stream a: bubbles
  ## stream b: bubbles
  ## stream c: bubbles
  ## stream d: bubbles
  ## stream e: bubbles
  ## ---
  ## 1: a = 7
  ## 1: e = 7
  ## 2: a = 5
  ## 3: b = 6
  ## 3: e = 6
  ## 4: b = 2
  ## 4: a = 3
  ## 4: e = 2
  ## 5: e = 1
  ## 5: c = 1
  ## 6: d = 2
  ## 6: e = 2
  ## 7: b = 4
  ## 7: a = 9
  ## 7: d = 2
  ## 7: e = 9
  ## 7: c = 3
  ## ~~~
  def lift4[T1, T2, T3, T4, T5](stream1: Events[T1], stream2: Events[T2], stream3: Events[T3], stream4: Events[T4],
                                f: (Option[T1], Option[T2], Option[T3], Option[T4]) => Option[T5]): Events[T5] = {
    def stream1and2 = lift(stream1, stream2, (x: Option[T1], y: Option[T2]) => Some((x, y)))
    lift3(stream1and2, stream3, stream4, (v1and2opt: Option[(Option[T1], Option[T2])], v3: Option[T3], v4: Option[T4]) =>
      if isNone(v1and2opt)
      then f(None[T1], None[T2], v3, v4)
      else {
        def v1and2 = getSome(v1and2opt)
        f(v1and2._1, v1and2._2, v3, v4)
      })
  }

  ## The last operator takes two streams and returns the previous
  ## value of the first stream at the timestamps of the second.
  ## Note that while TeSSLa is defined on event streams, last realizes some essential
  ## aspects of the signal semantics: With this operator one can query the last known
  ## value of an event stream at a specific time and hence interpret the events on this
  ## stream as points where a piece-wise constant signal changes its value.
  ##
  ## **Usage example:**
  ##
  ## ~~~ruby
  ## in values: Events[Int]
  ## in trigger: Events[Unit]
  ## def result = last(x,y)
  ## out result
  ## ~~~
  ##
  ## **Trace example:**
  ##
  ## ~~~trace
  ## stream values: bubbles
  ## stream trigger: unit events
  ## stream result: bubbles
  ## ---
  ## 1: trigger = ()
  ## 2: values = 5
  ## 3: result = 5
  ## 3: trigger = ()
  ## 4: result = 5
  ## 4: trigger = ()
  ## 4: values = 3
  ## 5: result = 3
  ## 5: trigger = ()
  ## ~~~
  ##
  def last[T, U](stream: Events[T], trigger: Events[U]): Events[T] = __builtin__(last)

  ## The time operator returns the stream of the timestamps of another stream
  ##
  ## **Usage example:**
  ##
  ## ~~~ruby
  ## in x: Events[Int]
  ## def y = time(x)
  ## out result
  ## ~~~
  ##
  ## **Trace example:**
  ##
  ## ~~~trace
  ## option axis: true
  ## option timeDomain: [0,14]
  ## stream x: bubbles
  ## stream y: bubbles
  ## ---
  ## 2: x = 5
  ## 2: y = 2
  ## 4: x = 3
  ## 4: y = 4
  ## 10: x = 42
  ## 10: y = 10
  ## ~~~
  ##
  def time[T](stream: Events[T]): Events[Int] = __builtin__(time)

  ## The delay operator takes delays as its first argument. After a
  ## delay has passed, a unit event is emitted. A delay can only be set if a reset event
  ## is received via the second argument, or if an event is emitted on the output.
  ##
  ## **Usage example:**
  ##
  ## ~~~ruby
  ## in values: Events[Int]
  ## in resets: Events[Int]
  ## def result = delay(values, resets)
  ## out result
  ## ~~~
  ##
  ## **Trace example:**
  ##
  ## ~~~trace
  ## option axis: true
  ## stream values: bubbles
  ## stream resets: unit events
  ## stream result: unit events
  ## ---
  ## 1: resets = ()
  ## 1: values = 2
  ## 3: result = ()
  ## 4: resets = ()
  ## 4: values = 3
  ## 7: result = ()
  ## 7: values = 2
  ## 9: result = ()
  ## 9: resets = ()
  ## 9: values = 2
  ## 11: result = ()
  ## 11: values = 4
  ## 13: resets = ()
  ## ~~~
  ##
  def delay[T](delays: Events[Int], resets: Events[T]): Events[Unit] = __builtin__(delay)

  # More stream functions

  ## Maps the event's values of a `stream` to given constant `value`.
  ##
  ## **Usage example:**
  ##
  ## ~~~ruby
  ## in x: Events[Int]
  ## def y = const(42, x)
  ## out y
  ## ~~~
  ##
  ## **Trace example:**
  ##
  ## ~~~trace
  ## stream x: bubbles
  ## stream y: bubbles
  ## ---
  ## 1: y = 42
  ## 1: x = 17
  ## 6: y = 42
  ## 6: x = 1
  ## 8: y = 42
  ## 8: x = 42
  ## 12: y = 42
  ## 12: x = 23
  ## ~~~
  def const[T, U](value: T, stream: Events[U]): Events[T] = slift1(stream, (_: U) => value)

  ## Returns a variant of `stream1` which has every original events of `stream1` and additional events with
  ## the last value of `stream1` for every event of `stream2`. `first` is defined as the signal lift of the
  ## function _f(a,b) = a_.
  ##
  ## Note, the difference between `first(stream1, stream2)` and `merge(stream1, last(stream1, stream2))`. Since `first` is
  ## defined via signal lift, it does not produce events before both input streams have been defined.
  ##
  ## **Usage example:**
  ##
  ## ~~~ruby
  ## in x: Events[Int]
  ## in y: Events[Int]
  ## def z = first(x, y)
  ## out z
  ## ~~~
  ##
  ## **Trace example:**
  ##
  ## ~~~trace
  ## stream x: signal
  ## stream y: signal
  ## stream z: signal
  ## ---
  ## 1: x = 17
  ## 2: y = 23
  ## 2: z = 17
  ## 3: z = 1
  ## 3: x = 1
  ## 4: y = 3
  ## 4: z = 1
  ## 6: y = 34
  ## 6: z = 42
  ## 6: x = 42
  ## 8: y = 12
  ## 8: z = 42
  ## ~~~
  def first[T, U](stream1: Events[T], stream2: Events[U]): Events[T] = slift(stream1, stream2, (x: T, _: U) => x)

  ## The unary signal lift is very similar to `lift1`. Since the lifted function is unary, there is no other
  ## stream with which events are being synchronized. The only difference is that `slift1` takes a total
  ## function which cannot remove events.
  ##
  ## **Usage example:**
  ##
  ## ~~~ruby
  ## in a: Events[Int]
  ## def b = slift1(a, (x: Int) => x + 1)
  ## out b
  ## ~~~
  ##
  ## **Trace example:**
  ##
  ## ~~~trace
  ## stream a: signal
  ## stream b: signal
  ## ---
  ## 1: b = 3
  ## 1: a = 2
  ## 3: b = 6
  ## 3: a = 5
  ## 7: b = 4
  ## 7: a = 3
  ## ~~~
  def slift1[T, U](stream: Events[T], f: (T) => U): Events[U] =
    lift1(stream, (x: Option[T]) => Some(f(getSome(x))))

  def slift[T,U,V](a: Events[T], b: Events[U], f: (T,U) => V): Events[V] = {
    def aa = merge(a, last(a, b))
    def bb = merge(b, last(b, a))
    lift(aa, bb, (x: Option[T], y: Option[U]) =>
      if isNone(x) || isNone(y)
      then None[V]
      else Some(f(getSome(x), getSome(y))))
  }

  def slift3[T1, T2, T3, T4](a: Events[T1], b: Events[T2], c: Events[T3], f: (T1, T2, T3) => T4): Events[T4] = {
    def aa = merge(a, last(a, mergeUnit(b, c)))
    def bb = merge(b, last(b, mergeUnit(a, c)))
    def cc = merge(c, last(c, mergeUnit(a, b)))
    lift3(aa, bb, cc, (x: Option[T1], y: Option[T2], z: Option[T3]) =>
      if isNone(x) || isNone(y) || isNone(z)
      then None[T4]
      else Some(f(getSome(x), getSome(y), getSome(z))))
  }

  def slift4[T1, T2, T3, T4, T5](s1: Events[T1], s2: Events[T2], s3: Events[T3], s4: Events[T4], f: (T1, T2, T3, T4) => T5): Events[T5] = {
    def ss1 = merge(s1, last(s1, mergeUnit3(s2, s3, s4)))
    def ss2 = merge(s2, last(s2, mergeUnit3(s1, s3, s4)))
    def ss3 = merge(s3, last(s3, mergeUnit3(s1, s2, s4)))
    def ss4 = merge(s4, last(s4, mergeUnit3(s1, s2, s3)))
    lift4(ss1, ss2, ss3, ss4, (v1: Option[T1], v2: Option[T2], v3: Option[T3], v4: Option[T4]) =>
      if isNone(v1) || isNone(v2) || isNone(v3) || isNone(v4)
      then None[T5]
      else Some(f(getSome(v1), getSome(v2), getSome(v3), getSome(v4))))
  }

  ## Return the previous event of `a`
  def prev[A](a: Events[A]) = last(a,a)

  def merge[T](stream1: Events[T], stream2: Events[T]): Events[T] =
    lift(stream1, stream2, (x: Option[T], y: Option[T]) => if isNone(x) then y else x)

  ## Filter the event stream `events` based on the last known value
  ## of the boolean signal `condition`.
  def filter[A](events: Events[A], condition: Events[Bool]) =
    lift(events, merge(condition, last(condition, events)), (e: Option[A], c: Option[Bool]) =>
      if isSome(c) && getSome(c) then e else None[A])

  ## Remove events with the same value
  def pure[T](x: Events[T]) =
    filter(x, merge(last(x,x) != x, true))

  ## Signal which is only true with first event on `x`
  def isFirst[A](x: Events[A]) = merge3(const(false, last(x,x)), const(true, x), false)

  ## Filters `x` such that only the first event on `x` remains
  def firstEvent[A](x: Events[A]) = filter(x, isFirst(x))

  ## Signal, which becomes `true` with the first event on `x`
  def hadAnyEvent[T](x: Events[T]) = merge(const(true, x), false)

  ## Compute the runtime of a function on every `ret` event.
  ## The runtime is the time passed between the last `call`
  ## event and the `ret` event. The values of the events are
  ## ignored.
  def runtime[A,B](call: Events[A], ret: Events[B]) =
    on(ret, time(ret) - time(call))

  ## Compute the maximum of two integer values.
  @liftable
  def max(a: Int, b: Int) = if a > b then a else b

  ## Compute the minimum of two integer values.
  @liftable
  def min(a: Int, b: Int) = if a < b then a else b

  ## Compute the maximum value of all events on `x`.
  ## Provides for every input event and output event
  ## whose value is the maximum up to this point.
  def maximum(x: Events[Int]) = reduce(x, max)

  ## Compute the minimum value of all events on `x`.
  ## Provides for every input event and output event
  ## whose value is the minimum up to this point.
  def minimum(x: Events[Int]) = reduce(x, min)

  ## Count the number of events on `x`. Provides for
  ## every input event an output event whose value is
  ## the number of events seen so far.
  ## See [`resetCount`](#resetcount) for a counting macro with an
  ## external reset.
  ##
  ## **Usage example:**
  ##
  ## ~~~ruby
  ## in x: Events[Unit]
  ## def y = count(x)
  ## out y
  ## ~~~
  ##
  ## **Trace example:**
  ##
  ## ~~~trace
  ## stream x: unit events
  ## stream y: signal
  ## ---
  ## 0: y = 0
  ## 2: y = 1
  ## 2: x = ()
  ## 6: y = 2
  ## 6: x = ()
  ## 7: y = 3
  ## 7: x = ()
  ## 9: y = 4
  ## 9: x = ()
  ## ~~~
  def count[T](x: Events[T]) = fold(x, 0, (x: Int, _: T) => x+1)

  ## Sum up the values of all events on `x`. Provides
  ## for every input event an output event whose value
  ## is the sum of the values of all events seen so far.
  def sum(x: Events[Int]) = fold(x, 0, __add__)

  ## Fold a function on values over all events on `stream`. Starting with
  ## the initial value `init` the function `f` is called for every event
  ## on `stream` with the last result and the current event’s value as arguments.
  ## So for the input stream `x`
  ##
  ## ~~~
  ## 2: x = 2
  ## 4: x = 6
  ## 5: x = 1
  ## ~~~
  ##
  ## the call `def y = fold(f, x, 0)` produces the following stream `y`:
  ##
  ## ~~~
  ## 0: y = 0
  ## 2: y = f(0,2)
  ## 4: y = f(f(0,2),6)
  ## 5: y = f(f(f(0,2),6),1)
  ## ~~~
  def fold[T,R](stream: Events[T], init: R, f: (R,T) => R) = result where {
    def result: Events[R] =
      default(
        lift(last(result, stream), stream, (acc: Option[R], curr: Option[T]) =>
          if isNone(curr) then None[R]
          else if isNone(acc) then Some(f(init, getSome(curr)))
          else Some(f(getSome(acc), getSome(curr)))
        ),
        init
      )
  }

  ## Fold a function on values over all events on `stream`. Starting with
  ## the first event on `stream` as initial value, the function `f` is called for every later event
  ## on `stream` with the last result and the current event’s value as arguments.
  ## So for the input stream `x`
  ##
  ## ~~~
  ## 2: x = 2
  ## 4: x = 6
  ## 5: x = 1
  ## ~~~
  ##
  ## the call `def y = reduce(f, x)` produces the following stream `y`:
  ##
  ## ~~~
  ## 2: y = 2
  ## 4: y = f(2,6)
  ## 5: y = f(f(2,6),1)
  ## ~~~
  def reduce[T](stream: Events[T], f: (Events[T],Events[T]) => Events[T]) = result where {
    def result: Events[T] = defaultFrom(f(last(result, stream), stream), stream)
  }

  ## Count the number of events on `events`. Reset the output to 0
  ## on every event on `reset`.
  def resetCount[A,B](events: Events[A], reset: Events[B]) = count where {
    def count: Events[Int] = default(
      # `reset` contains the latest event
      if default(time(reset) > time(events), false)
      then 0
      # `reset` and `events` latest event happen simultaneously
      else if default(time(reset) == time(events), false)
      then 1
      # `events` contains the latest event > increment counter
      else last(count, events) + 1,
      0)
  }

  ## Check if events on `e` follow the burst pattern:
  ## After first event on `e` only `burstAmount` many events allowed
  ## during `burstLength` time. After `burstLength` during `waitingPeriod`
  ## time no event allowed. After `waitingPeriod` we wait for the next event
  ## on `e`.
  def bursts[A](e: Events[A], burstLength: Int, waitingPeriod: Int, burstAmount: Int) := {
    def burstStarts: Events[A] :=
      defaultFrom(
        filter(e, time(e) - last(time(burstStarts), e) >= burstLength + waitingPeriod),
        e)
    resetCount(e, reset = burstStarts) <= burstAmount &&
      default(time(e) < time(burstStarts) + burstLength, true)
  }

  ## Check if events on `e` follow the burst pattern since the last event on `since`:
  ## After first event on `e` only `burstAmount` many events allowed
  ## during `burstLength` time. After `burstLength` during `waitingPeriod`
  ## time no event allowed. After `waitingPeriod` we wait for the next event
  ## on `e`.
  def burstsSince[A,B](e: Events[A], burstLength: Int, waitingPeriod: Int, burstAmount: Int, since: Events[B]) = {
    def burstStarts: Events[A] =
      defaultFrom(
        filter(e, last(time(burstStarts), e) < on(e, time(since)) ||
          time(e) - last(time(burstStarts), e) >= burstLength + waitingPeriod),
        e)
    resetCount(e, reset = burstStarts) <= burstAmount &&
      default(time(e) < time(burstStarts) + burstLength, true)
  }

  ## Check if no event happened on `on` after last event on `since`.
  def noEvent[A,B](on: Events[A], since: Events[B]) =
    resetCount(on, reset = since) == 0

  ## Produce an event with the given value every time that the condition is met
  def constIf[T](value: T, condition: Events[Bool]): Events[T] =
    filter(const(value, condition), condition)

  ## Produces a unit event every time the condition is fulfilled
  def unitIf(cond: Events[Bool]): Events[Unit] = constIf((), cond)

  ## Detect rising edge on `condition`.
  def rising(condition: Events[Bool]) =
    unitIf(condition && !prev(condition))

  ## Detect falling edge on `condition`
  def falling(condition: Events[Bool]) =
    unitIf(!condition && prev(condition))

  ## Produce the current or last value on `stream` for every `trigger`
  def on[A,B](trigger: Events[A], stream: Events[B]) = {
    def mergedStream = merge(stream, last(stream, trigger))
    lift(trigger, mergedStream, (trig: Option[A], str: Option[B]) =>
      if isNone(trig) then None[B] else str)
    # Alternatively:
    # filter(first(stream, trigger), time(trigger) >= time(stream))
  }

  ## Compute the average value of all events on `x`. For every input
  ## event on `x` an output event is produced whose value is the average
  ## of all values seen so far.
  def average(x: Events[Int]) = {
    def c = count(x)
    filter(sum(x) / c, c != 0)
  }

  ## Provides an event with value `true` for the first event on `a` and
  ## if there is no event on `a` with timestamp 0 then adds a default
  ## value of `false` to get a completely defined signal.
  def defined[A](a: Events[A]) = default(const(true, a), false)

  ## Merges streams of different types, resulting in a stream that contains a unit
  ## event whenever any of the input streams produces an event.
  def mergeUnit[T, U](a: Events[T], b: Events[U]) = merge(const((), a), const((), b))

  ## Merges the given event streams. Prioritizing the event streams
  ## from the left to the right in case of simultaneous events.
  def merge3[T](a: Events[T], b: Events[T], c: Events[T]) = merge(merge(a, b), c)

  ## Merges streams of different types, resulting in a stream that contains a unit
  ## event whenever any of the input streams produces an event.
  def mergeUnit3[T, U, V](a: Events[T], b: Events[U], c: Events[V]) = merge3(const((), a), const((), b), const((), c))

  ## Merges the given event streams. Prioritizing the event streams
  ## from the left to the right in case of simultaneous events.
  def merge4[T](a: Events[T], b: Events[T], c: Events[T], d: Events[T]) =
    merge(merge(a, b), merge(c, d))

  ## Merges the given event streams. Prioritizing the event streams
  ## from the left to the right in case of simultaneous events.
  def merge5[T](a: Events[T], b: Events[T], c: Events[T], d: Events[T], e: Events[T]) =
    merge(merge(merge(a, b), merge(c, d)), e)

  ## Merges the given event streams. Prioritizing the event streams
  ## from the left to the right in case of simultaneous events.
  def merge6[T](a: Events[T], b: Events[T], c: Events[T], d: Events[T], e: Events[T], f: Events[T]) =
    merge(merge(merge(a, b), merge(c, d)), merge(e, f))

  ## Merges the given event streams. Prioritizing the event streams
  ## from the left to the right in case of simultaneous events.
  def merge7[A](a: Events[A], b: Events[A], c: Events[A], d: Events[A], e: Events[A], f: Events[A], g: Events[A]) =
    merge(merge(merge(a, b), merge(c, d)), merge(merge(e, f), g))

  ## Merges the given event streams. Prioritizing the event streams
  ## from the left to the right in case of simultaneous events.
  def merge8[A](a: Events[A], b: Events[A], c: Events[A], d: Events[A], e: Events[A], f: Events[A], g: Events[A], h: Events[A]) =
    merge(merge(merge(a, b), merge(c, d)), merge(merge(e, f), merge(g, h)))

  ## Produce an event stream with a unit event every `delay` time units.
  ## Starting with an event at timestamp 0.
  def period(freq: Int) = {
    def s: Events[Int] = const(freq, default(delay(s, ()), ()))
    const((), s)
  }

  ## Filter out events to ensure a maximal event rate. Forwards the first event on `e` and
  ## afterwards every event which is at least `rate` time units later then the last
  ## forwarded event.
  def sample[A](e: Events[A], rate: Int): Events[A] = result where {
   def result: Events[A] =
     merge(filter(e, time(e) - last(time(result), e) >= rate), firstEvent(e))
  }

  # Additional types. Their functionality can be found in their respective modules, but the types are defined here,
  # so one can write, say, `List[Int]` instead of `List.List[Int]`.
  type List[T] = __builtin__(List)
  type Set[T] = __builtin__(Set)
  type Map[K, V] = __builtin__(Map)
#}