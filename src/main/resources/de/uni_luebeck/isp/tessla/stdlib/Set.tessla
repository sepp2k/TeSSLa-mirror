## Set
module Set {
  ## Returns an empty set without any element of type `T`
  def empty[T]: Set[T] = __builtin__(Set_empty)

  @liftable
  def singleton[T](value: T): Set[T] = add(empty[T], value)

  ## Add an item to the given `set`, if not already contained
  ##
  ## **Usage example:**
  ##
  ## ~~~ruby
  ## in x: Events[Int]
  ## def old = last(set, x)
  ## def set: Events[Set[Int]] = merge(Set.add(old, x), Set.empty[Int])
  ## out set
  ## ~~~
  ##
  ## **Trace example:**
  ##
  ## ~~~trace
  ## option timeDomain: [-1,10]
  ## stream x: events
  ## stream set: events
  ## ---
  ## 0: set = Set()
  ## 2: set = Set(1)
  ## 2: x = 1
  ## 4: set = Set(1, 2)
  ## 4: x = 2
  ## 6: set = Set(1, 2)
  ## 6: x = 2
  ## 8: set = Set(1, 2, -25)
  ## 8: x = -25
  ## ~~~
  @liftable
  def add[T](set: Set[T], item: T): Set[T] = __builtin__(Set_add)

  ## Returns [`true`](#true) if the given `set` contains the given item
  ##
  ## **Usage example:**
  ##
  ## ~~~ruby
  ## in x: Events[Int] # elements to add
  ## in y: Events[Int] # items to check
  ## def old = last(set, x)
  ## def set: Events[Set[Int]] = merge(Set.add(old, x), Set.empty[Int])
  ## def contains = Set.contains(set,y)
  ## out contains
  ## ~~~
  ##
  ## **Trace example:**
  ##
  ## ~~~trace
  ## option timeDomain: [-1,6]
  ## stream x: events
  ## stream y: events
  ## stream set: events
  ## stream contains: bubbles
  ## ---
  ## 0: y = 1
  ## 0: contains = false
  ## 0: set = Set()
  ## 2: y = 1
  ## 2: contains = true
  ## 2: set = Set(1)
  ## 2: x = 1
  ## 4: y = 1
  ## 4: contains = true
  ## 4: set = Set(1, 2)
  ## 4: x = 2
  ## ~~~
  @liftable
  def contains[T](set: Set[T], item: T): Bool = __builtin__(Set_contains)

  @liftable
  def remove[T](set: Set[T], item: T): Set[T] = __builtin__(Set_remove)

  ## Returns the number of elements in the given `set`
  ##
  ## **Usage example:**
  ##
  ## ~~~ruby
  ## in x: Events[Int]
  ## def old = last(set, x)
  ## def set: Events[Set[Int]] = merge(Set.add(old, x), Set.empty[Int])
  ## def size = Set.size(set)
  ## out size
  ## ~~~
  ##
  ## **Trace example:**
  ##
  ## ~~~trace
  ## option timeDomain: [-1,10]
  ## stream x: events
  ## stream set: events
  ## stream size: events
  ## ---
  ## 0: size = 0
  ## 0: set = Set()
  ## 2: size = 1
  ## 2: set = Set(1)
  ## 2: x = 1
  ## 4: size = 2
  ## 4: set = Set(1, 2)
  ## 4: x = 2
  ## 6: size = 3
  ## 6: set = Set(1, 2, 3)
  ## 6: x = 3
  ## 8: size = 3
  ## 8: set = Set(1, 2, 3)
  ## 8: x = 2
  ## ~~~
  @liftable
  def size[T](set: Set[T]): Int = __builtin__(Set_size)

  @liftable
  def union[T](set1: Set[T], set2: Set[T]): Set[T] = __builtin__(Set_union)

  @liftable
  def intersection[T](set1: Set[T], set2: Set[T]): Set[T] = __builtin__(Set_intersection)

  @liftable
  def minus[T](set1: Set[T], set2: Set[T]): Set[T] = __builtin__(Set_minus)

  @liftable
  def fold[T, U](set: Set[T], start: U, f: (U, T) => U): U = __builtin__(Set_fold)

  def collect[T](value: Events[T]) = {
    def set: Events[Set[T]] = default(add(last(set, value), value), empty[T])
    set
  }

  def collectWithRemove[T](value: Events[T], removeValue: Events[T]) = {
    def old = last(set, merge(value, removeValue))
    def operation: Events[Set[T]] = lift3(old, value, removeValue, (o: Option[Set[T]], v: Option[T], r: Option[T]) =>
      Some(minus(union(getSome(o), Option.toSet(v)), Option.toSet(r))))
    def set = default(operation, empty[T])
    set
  }
}

# Define the type outside of the module
# so one can write `Set[Int]` instead of `Set.Set[Int]`.
type Set[T] = __builtin__(Set)