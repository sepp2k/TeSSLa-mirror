## Lists
module List {

  ## Returns an empty list without any element of type `T`
  def empty[T]: List[T] = __builtin__(List_empty)

  ## Returns the number of elements in the given `list`
  ##
  ## **Usage example:**
  ##
  ## ~~~ruby
  ## in x: Events[Int]
  ## def old = last(list, x)
  ## def list: Events[List[Int]] = merge(List.append(old, x), List.empty[Int])
  ## def size = List.size(list)
  ## out size
  ## ~~~
  ##
  ## **Trace example:**
  ##
  ## ~~~trace
  ## option timeDomain: [-1,8]
  ## stream x: events
  ## stream list: events
  ## stream size: events
  ## ---
  ## 0: size = 0
  ## 0: list = List()
  ## 2: size = 1
  ## 2: list = List(1)
  ## 2: x = 1
  ## 4: size = 2
  ## 4: list = List(1, 2)
  ## 4: x = 2
  ## 6: size = 3
  ## 6: list = List(1, 2, 3)
  ## 6: x = 3
  ## ~~~
  @liftable
  def size[T](list: List[T]): Int = __builtin__(List_size)

  ## Returns [`true`](#true) if the given `list` has a size of zero
  ##
  ## **Usage example:**
  ##
  ## ~~~ruby
  ## in x: Events[Int]
  ## def old = last(list, x)
  ## def list: Events[List[Int]] = merge(List.append(old, x), List.empty[Int])
  ## def empty = List.isEmpty(list)
  ## out empty
  ## ~~~
  ##
  ## **Trace example:**
  ##
  ## ~~~trace
  ## option timeDomain: [-1,8]
  ## stream x: events
  ## stream list: events
  ## stream empty: bubbles
  ## ---
  ## 0: empty = true
  ## 0: list = List()
  ## 2: empty = false
  ## 2: list = List(1)
  ## 2: x = 1
  ## 4: empty = false
  ## 4: list = List(1, 2)
  ## 4: x = 2
  ## 6: empty = false
  ## 6: list = List(1, 2, 3)
  ## 6: x = 3
  ## ~~~
  @liftable
  def isEmpty[T](list: List[T]): Bool = size(list) == 0

  ## Appends the given `element` to the end of the given `list`
  ##
  ## **Usage example:**
  ##
  ## ~~~ruby
  ## in x: Events[Int]
  ## def old = last(list, x)
  ## def list: Events[List[Int]] = merge(List.append(old, x), List.empty[Int])
  ## out list
  ## ~~~
  ##
  ## **Trace example:**
  ##
  ## ~~~trace
  ## option timeDomain: [-1,8]
  ## stream x: events
  ## stream list: events
  ## ---
  ## 0: list = List()
  ## 2: list = List(1)
  ## 2: x = 1
  ## 4: list = List(1, 2)
  ## 4: x = 2
  ## 6: list = List(1, 2, 3)
  ## 6: x = 3
  ## ~~~
  @liftable
  def append[T](list: List[T], element: T): List[T] = __builtin__(List_append)

  ## Prepends the given `element` to the begining of the given `list`
  ##
  ## **Usage example:**
  ##
  ## ~~~ruby
  ## in x: Events[Int]
  ## def old = last(list, x)
  ## def list: Events[List[Int]] = merge(List.prepend( x, old), List.empty[Int])
  ## out list
  ## ~~~
  ##
  ## **Trace example:**
  ##
  ## ~~~trace
  ## option timeDomain: [-1,8]
  ## stream x: events
  ## stream list: events
  ## ---
  ## 0: list = List()
  ## 2: list = List(1)
  ## 2: x = 1
  ## 4: list = List(2, 1)
  ## 4: x = 2
  ## 6: list = List(3, 2, 1)
  ## 6: x = 3
  ## ~~~
  @liftable
  def prepend[T](element: T, list: List[T]): List[T] = __builtin__(List_prepend)

  ## Selects all elements except the first
  ##
  ## **Usage example:**
  ##
  ## ~~~ruby
  ## in x: Events[Int]
  ## def old = last(list, x)
  ## def list: Events[List[Int]] = merge(List.append(old, x), List.empty[Int])
  ## def tail = filter(List.tail(list), !(List.isEmpty(list)))
  ## out tail
  ## ~~~
  ##
  ## **Trace example:**
  ##
  ## ~~~trace
  ## option timeDomain: [-1,8]
  ## stream x: events
  ## stream list: events
  ## stream tail: events
  ## ---
  ## 0: list = List()
  ## 2: tail = List()
  ## 2: list = List(1)
  ## 2: x = 1
  ## 4: tail = List(2)
  ## 4: list = List(1, 2)
  ## 4: x = 2
  ## 6: tail = List(2, 3)
  ## 6: list = List(1, 2, 3)
  ## 6: x = 3
  ## ~~~
  @liftable
  def tail[T](list: List[T]): List[T] = __builtin__(List_tail)

  ## Selects all elements except the last
  ##
  ## **Usage example:**
  ##
  ## ~~~ruby
  ## in x: Events[Int]
  ## def old = last(list, x)
  ## def list: Events[List[Int]] = merge(List.append(old, x), List.empty[Int])
  ## def init = filter(List.init(list), !(List.isEmpty(list)))
  ## out init
  ## ~~~
  ##
  ## **Trace example:**
  ##
  ## ~~~trace
  ## option timeDomain: [-1,8]
  ## stream x: events
  ## stream list: events
  ## stream init: events
  ## ---
  ## 0: init = List()
  ## 0: list = List()
  ## 2: init = List()
  ## 2: list = List(1)
  ## 2: x = 1
  ## 4: init = List(1)
  ## 4: list = List(1, 2)
  ## 4: x = 2
  ## 6: init = List(1, 2)
  ## 6: list = List(1, 2, 3)
  ## 6: x = 3
  ## ~~~
  @liftable
  def init[T](list: List[T]): List[T] = __builtin__(List_init)

  ## Gets the element at the requested `index`
  @liftable
  def get[T](list: List[T], index: Int): T = __builtin__(List_get)

  ## Sets the value at the given `index`
  @liftable
  def set[T](list: List[T], index: Int, value: T): List[T] = __builtin__(List_set)

  ## Selects the first element
  ##
  ## **Usage example:**
  ##
  ## ~~~ruby
  ## in x: Events[Int]
  ## def old = last(list, x)
  ## def list: Events[List[Int]] = merge(List.append(old, x), List.empty[Int])
  ## def head = filter(List.head(list), !(List.isEmpty(list)))
  ## out head
  ## ~~~
  ##
  ## **Trace example:**
  ##
  ## ~~~trace
  ## option timeDomain: [-1,8]
  ## stream x: events
  ## stream list: events
  ## stream head: events
  ## ---
  ## 0: list = List()
  ## 2: x = 1
  ## 2: list = List(1)
  ## 2: head = 1
  ## 4: x = 2
  ## 4: list = List(1, 2)
  ## 4: head = 1
  ## 6: x = 3
  ## 6: list = List(1, 2, 3)
  ## 6: head = 1
  ## ~~~
  @liftable
  def head[T](list: List[T]): T = get(list, 0)

  ## Selects the last element
  ##
  ## **Usage example:**
  ##
  ## ~~~ruby
  ## in x: Events[Int]
  ## def old = last(list, x)
  ## def list: Events[List[Int]] = merge(List.append(old, x), List.empty[Int])
  ## def l = filter(List.last(list), !(List.isEmpty(list)))
  ## out l
  ## ~~~
  ##
  ## **Trace example:**
  ##
  ## ~~~trace
  ## option timeDomain: [-1,8]
  ## stream x: events
  ## stream list: events
  ## stream l: events
  ## ---
  ## 0: list = List()
  ## 2: x = 1
  ## 2: list = List(1)
  ## 2: l = 1
  ## 4: x = 2
  ## 4: list = List(1, 2)
  ## 4: l = 2
  ## 6: x = 3
  ## 6: list = List(1, 2, 3)
  ## 6: l = 3
  ## ~~~
  @liftable
  def last[T](list: List[T]): T = get(list, size(list)-1)

  ## Fold a function `f` on all values of the `list`. Starting with
  ## the initial value `start` the function `f` is called for every element
  ## of `list` with the last result and the current elementsâ€™s value as arguments.
  ## **Usage example:**
  ##
  ## ~~~ruby
  ## in x: Events[Int]
  ## def old = last(list, x)
  ## def list: Events[List[Int]] = merge(List.append(old, x), List.empty[Int])
  ## def s = List.fold(list, 0, (a:Int,b:Int) => a + b)
  ## out s
  ## ~~~
  ##
  ## **Trace example:**
  ##
  ## ~~~trace
  ## option timeDomain: [-1,8]
  ## stream x: events
  ## stream list: events
  ## stream s: events
  ## ---
  ## 0: s = 0
  ## 0: list = List()
  ## 2: s = 1
  ## 2: list = List(1)
  ## 2: x = 1
  ## 4: s = 3
  ## 4: list = List(1, 2)
  ## 4: x = 2
  ## 6: s = 6
  ## 6: list = List(1, 2, 3)
  ## 6: x = 3
  ## ~~~
  @liftable
  def fold[T, U](list: List[T], start: U, f: (U, T) => U): U = __builtin__(List_fold)
}

# Define the type outside of the module
# so one can write `List[Int]` instead of `List.List[Int]`.
type List[T] = __builtin__(List)