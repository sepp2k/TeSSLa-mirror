## MITL[S_{0,∞}]
module MITL {
  ## a S[0, x] b, x > 0
  def since0(x: Int, a: Events[Bool], b: Events[Bool]): Events[Bool] =
    merge3(
      constIf(true, a&&b),
      constIf(false, !a),
      on(delay(constIf(x, !b), falling(b)), false)
    )

  ## a S[x, ∞] b, x ≥ 0
  def sinceInfinity(x: Int, a: Events[Bool], b: Events[Bool]): Events[Bool] =
    static if x == 0
    then merge(
        constIf(true, a&&b),
        constIf(false, !a)
      )
    else {
      def firstA: Events[Bool] = merge(const(true, rising(default(a, false))), last(firstA, b) && b)
      def start = unitIf(on(b, firstA))
      merge(
        on(delay(on(start, x), merge(start, unitIf(!a))), true),
        constIf(false, !a)
      )
    }

  ## O[0, x] a
  def once0(x: Int, a: Events[Bool]) = since0(x, true, a)

  ## O[x, ∞] a
  def onceInfinity(x: Int, a: Events[Bool]) = sinceInfinity(x, true, a)

  ## H[0, x] a
  def historically0(x: Int, a: Events[Bool]) = !once0(x, !a)

  ## H[x, ∞] a
  def historicallyInfinity(x: Int, a: Events[Bool]) = !onceInfinity(x, !a)
}

## past-time LTL
module LTL {
  ## a S b
  def since(a: Events[Bool], b: Events[Bool]): Events[Bool] = MITL.sinceInfinity(0, a, b)

  ## O a
  def once(a: Events[Bool]): Events[Bool] = since(true, a)

  ## H a
  def historically(a: Events[Bool]): Events[Bool] = !once(!a)
}
