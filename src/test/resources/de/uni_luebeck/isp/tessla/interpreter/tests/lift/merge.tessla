in x: Events[Int]
in y: Events[Int]

def merge[T](a: Events[T], b: Events[T]): Events[T] := lift(a, b, aux) where {
  # Unlike the built-in merge this one prefers the second stream in case of
  # ties. This is so this is distinguishable from the built-in merge making
  # this test more robust in the presence of scoping bugs.
  def aux(a: Option[T], b: Option[T]): Option[T] := {
    def isSome[T](opt: Option[T]) := !isNone(opt)
    return if isSome(b) then b else a
  }
}

out merge(x, y) as m