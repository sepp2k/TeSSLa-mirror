def checkValidCall := function_call("check_valid")

def checkValidReturn := function_return("check_valid")

def checkValidRuntime := runtime(checkValidCall, checkValidReturn)

def maxCheckValidRuntime := max(checkValidRuntime)

def runtime(call: Events[Unit], ret: Events[Unit]) :=
  at(ret, time(ret) - time(call))

def at[A,B](trigger: Events[A], values: Events[B]) :=
  filter(values, time(trigger) == time(values))

def fold[T,R](f: (Events[R], Events[T]) => Events[R], stream: Events[T], init: R) := result where {
  def result: Events[R] := merge(f(last(result, stream), stream), init)
}

@liftable
def maximum(a: Int, b: Int) := if a > b then a else b

def max(x: Events[Int]) := fold(maximum, x, 0)

out checkValidCall
out checkValidReturn

in line: Events[Int]
in column: Events[Int]
in thread_id: Events[Int]
in instruction: Events[String]
in function: Events[String]
in functioncall: Events[String]
in operandcount: Events[Int]

in debug_slot: Events[Int]
in debug_value: Events[Int]

def code_line_exec(l: Int) := filterConst((), line == l && last(line, line) != l)
def function_call(name: String) := filterConst((), functioncall == name)
def function_return(name: String) := filterConst((), function == name && instruction == "ret")

def filterConst[T](x: T, cond: Events[Bool]): Events[T] = lift(cond, nil[Unit], (c: Option[Bool], nix: Option[Unit]) =>
    if getSome(c) then Some(x) else None[T]
)