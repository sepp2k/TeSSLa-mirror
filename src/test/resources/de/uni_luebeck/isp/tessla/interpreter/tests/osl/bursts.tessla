def send := function_call("sendValue")
out send # unit events

def property :=
    bursts(send, burstLength = 3s,
      waitingPeriod = 2s, burstAmount = 4)
out pure(property) as property # signal














-- Standard Library

def resetCount[A,B](values: Events[A], reset: Events[B]) := {
    def count: Events[Int] := default(
        if default(time(reset) > time(values), false)
        then 0
        else if default(time(reset) == time(values), false)
        then 1
        else last(count, values) + 1,
        0)
    count
}

def bursts[A](e: Events[A], burstLength: Int, waitingPeriod: Int, burstAmount: Int) := {
    def burstStarts: Events[A] :=
        defaultFrom(
            if time(e) - last(time(burstStarts), e) >= burstLength + waitingPeriod
            then e,
            e)
    resetCount(e, burstStarts) <= burstAmount &&
        time(e) < time(burstStarts) + burstLength
}

# Return the previous event of `a`
def prev[A](a: Events[A]) := last(a,a)

# Filter events with the same value
def pure[A](x: Events[A]) := if default(x != prev(x), true) then x

in line: Events[Int]
in column: Events[Int]
in thread_id: Events[Int]
in instruction: Events[String]
in function: Events[String]
in functioncall: Events[String]

in debug_slot: Events[Int]
in debug_value: Events[Int]

def code_line_exec(l: Int) := if line == l && last(line, line) != l then ()
def function_call(name: String) := if functioncall == name then ()
def function_return(name: String) := if function == name && instruction == "ret" then ()
