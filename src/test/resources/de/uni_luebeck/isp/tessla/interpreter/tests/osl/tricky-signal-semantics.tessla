in functioncall: Events[String]
in line_reached: Events[Int]
in column: Events[Int]
in function: Events[String]
in instruction: Events[String]

-- The tricky part here is that whenever we log that `function == "foo"`, we need to
-- also log the current values of both instruction and functioncall (not just the one
-- that fits the condition that's fulfilled now). If we don't, the other condition will
-- use an outdated value and might evaluate to true when it isn't supposed to.
out filterConst((), function == "foo" && instruction == "ret")
out filterConst((), function == "foo" && functioncall == "bar")

-- The fact that we log all lines should not affect the logging of the other properties
out line_reached

def filterConst[T](x: T, cond: Events[Bool]): Events[T] = lift(cond, nil[Unit], (c: Option[Bool], nix: Option[Unit]) =>
    if getSome(c) then Some(x) else None[T]
)