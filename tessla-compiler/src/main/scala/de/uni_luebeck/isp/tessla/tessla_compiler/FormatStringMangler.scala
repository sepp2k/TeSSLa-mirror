package de.uni_luebeck.isp.tessla.tessla_compiler

import de.uni_luebeck.isp.tessla.core.TranslationPhase
import de.uni_luebeck.isp.tessla.core.TranslationPhase.Success
import de.uni_luebeck.isp.tessla.core.TesslaAST.Core._

import java.util
import scala.collection.mutable

/**
 * This object is part of the translation pipeline of the Rust backend. The idea behind this is that format strings must
 * be known in Rust at compile time. This translation stage therefore looks in the ExtendedSpecification from the
 * TeSSLa core for all String.format() calls and adds the default stream and its corresponding nil stream generated by
 * the TeSSLa core to a list. All streams contained in this list are later ignored by TesslaCoreToRust stage and
 * consequently not generated in the Rust code. In addition, this translation stage passes a HashMap that maps the
 * removed format string streams to their corresponding format strings to the next compiler stage, so that they then can
 * be statically generated into the Rust code.
 */
object FormatStringMangler extends TranslationPhase[ExtendedSpecification, (ExtendedSpecification, util.ArrayList[String], mutable.HashMap[String, String])] {
  override def translate(spec: ExtendedSpecification): TranslationPhase.Result[(ExtendedSpecification, util.ArrayList[String], mutable.HashMap[String, String])] = {
    System.out.println("lul")

    var removedStreams = new util.ArrayList[String]()
    var formatStrings = new mutable.HashMap[String, String]()

    // Find every slift that uses extern("String_format")
    spec.spec.definitions.foreach {
      case (sliftid, definition) =>
        definition match {
          case ApplicationExpression(TypeApplicationExpression(ExternExpression("slift", _, _), _, _), args, location) =>
            args(2) match {
              case TypeApplicationExpression(ExternExpression("String_format", _, loc), _, _) =>
                args(0) match {
                  case ExpressionRef(id, _, _) =>
                    // If we encounter this format string the first time
                    if (!removedStreams.contains(id.fullName)) {
                      spec.spec.definitions.get(id) match {
                        // Ensure that the format string is stored on a nil stream using default
                        case Some(ApplicationExpression(TypeApplicationExpression(ExternExpression("default", _, _), _, _), args, _)) =>
                          var stream = args(0) match { // the stream the format string is based on
                            case ExpressionRef(id, _, _) => id
                            case _ =>
                              throw Diagnostics.CommandNotSupportedError("Can't determine format string at compile time.", loc)
                          }

                          // Do nothing if the format string is based on a nil stream
                          spec.spec.definitions.get(stream) match {
                            case Some(ApplicationExpression(TypeApplicationExpression(ExternExpression("nil", _, _), _, _), args, _)) => {}
                            case _ =>
                              throw Diagnostics.CommandNotSupportedError("Can't determine format string at compile time.", loc)
                          }

                          // Remove the nil stream
                          removedStreams.add(stream.fullName)

                          var format = args(1) match { // the format string itself
                            case StringLiteralExpression(value, _) => value
                            case _ =>
                              throw Diagnostics.CommandNotSupportedError("Can't determine format string at compile time.", loc)
                          }

                          // Add the format string to the map
                          formatStrings.addOne((id.fullName, format))

                          // Remove the format string stream
                          removedStreams.add(id.fullName)
                        case _ =>
                          throw Diagnostics.CommandNotSupportedError("Can't determine format string at compile time.", loc)
                      }
                    }

                    // We encountered the format string already and removed the streams
                    else /* we just need to map the slift to the corresponding format string */ {
                      formatStrings.addOne((sliftid.fullName, formatStrings(id.fullName)))
                    }
                }
            }

          case _ => {}
        }
    }

    Success((spec, removedStreams, formatStrings), Seq())
  }
}
