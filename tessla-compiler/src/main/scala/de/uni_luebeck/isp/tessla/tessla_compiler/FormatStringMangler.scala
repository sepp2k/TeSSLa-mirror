package de.uni_luebeck.isp.tessla.tessla_compiler

import de.uni_luebeck.isp.tessla.core.TesslaAST.Core._
import de.uni_luebeck.isp.tessla.core.TranslationPhase
import de.uni_luebeck.isp.tessla.core.TranslationPhase.Success

import java.util
import scala.collection.mutable
import scala.util.control.Breaks._

/**
 * This object is part of the translation pipeline of the Rust backend. The idea behind this is that format strings must
 * be known in Rust at compile time. This translation stage therefore looks in the ExtendedSpecification from the
 * TeSSLa core for all String.format() calls and adds the default stream and its corresponding nil stream generated by
 * the TeSSLa core to a list. All streams contained in this list are later ignored by TesslaCoreToRust stage and
 * consequently not generated in the Rust code. In addition, this translation stage passes a HashMap that maps the
 * removed format string streams to their corresponding format strings to the next compiler stage, so that they then can
 * be statically generated into the Rust code.
 */
object FormatStringMangler
    extends TranslationPhase[
      ExtendedSpecification,
      (ExtendedSpecification, util.ArrayList[String], mutable.HashMap[String, String])
    ] {
  override def translate(
    spec: ExtendedSpecification
  ): TranslationPhase.Result[(ExtendedSpecification, util.ArrayList[String], mutable.HashMap[String, String])] = {
    val removedStreams = new util.ArrayList[String]()
    val formatStrings = new mutable.HashMap[String, String]()

    // Find every slift that uses extern("String_format")
    spec.spec.definitions.foreach {
      case (sliftid, definition) =>
        definition match {
          case ApplicationExpression(TypeApplicationExpression(ExternExpression("slift", _, _), _, _), args, _)
            if args.length >= 3 =>
            args(2) match {
              case TypeApplicationExpression(ExternExpression("String_format", _, loc), _, _) =>
                args(0) match {
                  case ExpressionRef(id, _, _) =>
                    // If we encounter this format string the first time
                    if (!removedStreams.contains(id.fullName)) {
                      spec.spec.definitions.get(id) match {
                        // Ensure that the format string is stored on a nil stream using default
                        case Some(
                        ApplicationExpression(
                        TypeApplicationExpression(ExternExpression("default", _, _), _, _),
                        args,
                        _
                        )
                        ) =>
                          val stream = args(0) match { // the stream the format string is based on
                            case ExpressionRef(id, _, _) => id
                            case _ =>
                              throw Diagnostics.CommandNotSupportedError(
                                "Can't determine format string at compile time.",
                                loc
                              )
                          }

                          // Do nothing if the format string is based on a nil stream
                          spec.spec.definitions.get(stream) match {
                            case Some(
                            ApplicationExpression(
                            TypeApplicationExpression(ExternExpression("nil", _, _), _, _),
                            _,
                            _
                            )
                            ) => {}
                            case _ =>
                              throw Diagnostics.CommandNotSupportedError(
                                "Can't determine format string at compile time.",
                                loc
                              )
                          }

                          // Remove the nil stream
                          removedStreams.add(stream.fullName)

                          var format = args(1) match { // the format string itself
                            case StringLiteralExpression(value, _) => value
                            case _ =>
                              throw Diagnostics.CommandNotSupportedError(
                                "Can't determine format string at compile time.",
                                loc
                              )
                          }

                          // Add the format string to the map
                          formatStrings.addOne((id.fullName, format))

                          // Remove the format string stream
                          removedStreams.add(id.fullName)
                        case _ =>
                          throw Diagnostics.CommandNotSupportedError(
                            "Can't determine format string at compile time.",
                            loc
                          )
                      }
                    }

                    // We encountered the format string already and removed the streams
                    else
                    /* we just need to map the slift to the corresponding format string */ {
                      formatStrings.addOne((sliftid.fullName, formatStrings(id.fullName)))
                    }
                  case _ => {}
                }
              case _ => {}
            }

          case _ => {}
        }
    }

    Success((spec, removedStreams, formatStrings), Seq())
  }

  /**
   * Parses the specified TeSSLa format string.
   *
   * @param fs The format string to parse.
   * @return The extracted format string specification.
   */
  def parseFormatString(fs: String): FormatStringSpecification = {
    var spec: FormatStringSpecification = new FormatStringSpecification()

    if (fs.length < 2) {
      throw Diagnostics.CommandNotSupportedError("Invalid format string.")
    }
    if (fs[0] != '%') {
      throw Diagnostics.CommandNotSupportedError("Format string does not start with '%'.")
    }

    var i = 1

    // Extract flags; each only allowed once
    breakable {
      while (true) {
        fs.charAt(i) match {
          case '-' => if (!spec.leftJustify) {
            spec.leftJustify = true
          } else {
            throw Diagnostics.CommandNotSupportedError("Invalid format string.")
          }
          case '+' => if (!spec.plusSign) {
            spec.plusSign = true
          } else {
            throw Diagnostics.CommandNotSupportedError("Invalid format string.")
          }
          case ' ' => if (!spec.padSign) {
            spec.padSign = true
          } else {
            throw Diagnostics.CommandNotSupportedError("Invalid format string.")
          }
          case '#' => if (!spec.altForm) {
            spec.altForm = true
          } else {
            throw Diagnostics.CommandNotSupportedError("Invalid format string.")
          }
          case '0' => if (!spec.zeroPad) {
            spec.zeroPad = true
          } else {
            throw Diagnostics.CommandNotSupportedError("Invalid format string.")
          }
          case ',' => if (!spec.localeSeparators) {
            spec.localeSeparators = true
          } else {
            throw Diagnostics.CommandNotSupportedError("Invalid format string.")
          }
          case '(' => if (!spec.encloseNegatives) {
            spec.encloseNegatives = true
          } else {
            throw Diagnostics.CommandNotSupportedError("Invalid format string.")
          }
          case _ => break
        }
      }

      i += 1
    }

    try {
      // Extract width, don't allow zeroes
      if (fs.charAt(i) != '0' && fs.charAt(i).isDigit) {
        val j = i;

        while (fs.charAt(i).isDigit) {
          i += 1
        }

        spec.width = Integer.parseInt(fs.substring(j, i))
      }

      // Extract the format specifier
      spec.formatType = fs.charAt(i)

      // Determine whether the output should be in upper case
      if (spec.formatType.isUpper) {
        spec.uppercase = true
        spec.formatType = spec.formatType.toLower
      }
    } catch
    {
      case e: Exception => throw Diagnostics.CommandNotSupportedError("Invalid format string: " + e.getMessage)
    }

    if (i + 1 != fs.length) {
      throw Diagnostics.CommandNotSupportedError("Invalid format string.")
    }

    spec
  }

  /**
   * Specifies a format string.
   */
  class FormatStringSpecification {
    /**
     * Left justify withing the given field of width FmtWidth.
     */
    var leftJustify = false

    /**
     * Precede the output with a '+', unless the value is negative.
     */
    var plusSign = false

    /**
     * If no sign is written, write a space (0x20) instead.
     */
    var padSign = false

    /**
     * Precede integer with 0 for o, 0x for x and 0X for X.
     */
    var altForm = false

    /**
     * Left-pad the number with 0 if a padding is specified.
     */
    var zeroPad = false

    /**
     * Use a locale-specific grouping separator.
     */
    var localeSeparators = false

    /**
     * Enclose negative numbers with parenthesis.
     */
    var encloseNegatives = false

    /**
     * A non-negative decimal integer specifying the minimal number
     * of characters written to the output.
     */
    var width = 0

    /**
     * The maximum numbers of characters written for floating points.
     * Not applicable to o, d, x and X types.
     */
    var precision = 0

    /**
     * Indicates whether the output should be in upper case.
     */
    var uppercase = false

    /**
     * The format specifier.
     */
    var formatType = '?'

    /**
     * Determines whether this format specifier specifies an integer format.
     *
     */
    def isInteger() = {
      formatType == 'x' || formatType == 'o' || formatType == 'd'
    }

    /**
     * Determines whether this format specifier specifies a floating point format.
     */
    def isFloat() = {
      formatType == 'f' || formatType == 'g' || formatType == 'e' || formatType == 'a'
    }

    /**
     * Determines whether this format specifies neither an integer nor a floating
     * point format.
     */
    def isOther() = {
      !isFloat() && !isInteger()
    }
  }

  /**
   * Translates the specified format string into a format string
   * that can be fed into Rusts format!-macro.
   *
   * @param fs The format string to translate.
   * @return A format string for Rusts format!-macro.
   */
  def produceRustFormatString(fs: FormatStringSpecification): String = {
    if (fs.formatType == 'a') {
      throw Diagnostics.CommandNotSupportedError("Hexadecimal floating point literals aren't supported in Rust format strings.")
    }
    if (fs.localeSeparators) {
      throw Diagnostics.CommandNotSupportedError("Locale-specific grouping separators aren't supported in Rust format strings.")
    }
    if (fs.isOther && fs.zeroPad) {
      throw Diagnostics.CommandNotSupportedError("Strings can be zero-padded.")
    }
    if (fs.precision > 0 && fs.isInteger) {
      throw Diagnostics.CommandNotSupportedError("Integer formats can't use a precision")
    }

    // Apply format flags
    var str = "{:"
    if (fs.altForm) {
      str += '#'
    }
    if (fs.zeroPad) {
      str += '0'
    }
    if (fs.leftJustify) {
      str += '<'
    } else {
      str += '>'
    }
    if (fs.plusSign) {
      str += '+'
    }
    str += fs.width;
    if (fs.precision > 0) {
      str += '.'
      str += fs.precision
    }

    // Add format specifier
    if (fs.formatType == 'x') {
      str += (if (fs.uppercase) {'X'} else {'x'})
    }
    if (fs.formatType == 's' || fs.formatType == 'd') {
      // Add nothing
    }
    if (fs.formatType == 'o') {
      str += 'o'
    }
    if (fs.formatType == 'e') {
      str += 'e'
    }

    str += '}'
    str

    // TODO: Rust: padSign, encloseNegatives, upper case strings, g
  }
}
