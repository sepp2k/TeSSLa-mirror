/*
 * Copyright 2022 The TeSSLa Community
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package de.uni_luebeck.isp.tessla.tessla_compiler.backends.rustBackend.preprocessing

import cats.data.Ior
import de.uni_luebeck.isp.tessla.core.TesslaAST.Core._
import de.uni_luebeck.isp.tessla.core.TranslationPhase.Success
import de.uni_luebeck.isp.tessla.core.{Location, TesslaAST, TranslationPhase}

import scala.collection.immutable.ArraySeq

/**
 * This translation step remaps all identifiers to make them comply with Rust spec.
 *
 * - Underscores are replaced with double underscores. This is done to give single underscores special meaning,
 *   since they are then only generated by the other rules here.
 *
 * - The '$' character is replaced with '_', because the dollar sign is restricted for use in macros.
 *
 * - Rust keywords are prefixed with 'k_'.
 *
 * - Any unicode characters that are not in <a href="https://unicode.org/reports/tr31/#R1">UAX31-R1</a> are mapped to
 *   their hex representation.
 */
object SanitizeIdentifiers extends TranslationPhase[Specification, Specification] {
  override def translate(spec: TesslaAST.Core.Specification): TranslationPhase.Result[TesslaAST.Core.Specification] = {

    val in = spec.in.map {
      case (id, (typ, annotations)) =>
        val inputAnnotations = annotations ++ Map("$name" -> ArraySeq(StringLiteralExpression(id.toString)))
        (escapeIdentifier(id), (escapeType(typ), inputAnnotations))
    }

    val out = spec.out.map {
      case (ExpressionRef(id, typ, location), annotations) =>
        (ExpressionRef(escapeIdentifier(id), escapeType(typ), location), annotations)
    }

    val definitions = spec.definitions.map {
      case (id, definition) =>
        (escapeIdentifier(id), findAndEscapeIdentifiers(definition).asInstanceOf[DefinitionExpression])
    }

    Success(
      Specification(spec.annotations, in, definitions, out, spec.maxIdentifier),
      Seq()
    )
  }

  private def findAndEscapeIdentifiers(expr: ExpressionArg): ExpressionArg = expr match {
    case ExpressionRef(id, typ, location) => ExpressionRef(escapeIdentifier(id), escapeType(typ), location)
    case FunctionExpression(typeParams, params, body, result, location) =>
      FunctionExpression(
        typeParams.map(escapeIdentifier),
        params.map {
          case (id, eval, typ) =>
            (escapeIdentifier(id), eval, escapeType(typ))
        },
        body.map {
          case (id, definition) =>
            (escapeIdentifier(id), findAndEscapeIdentifiers(definition).asInstanceOf[DefinitionExpression])
        },
        findAndEscapeIdentifiers(result),
        location
      )
    case ApplicationExpression(applicable, args, location) =>
      ApplicationExpression(findAndEscapeIdentifiers(applicable), args.map(findAndEscapeIdentifiers), location)
    case TypeApplicationExpression(applicable, typeArgs, location) =>
      TypeApplicationExpression(findAndEscapeIdentifiers(applicable), typeArgs.map(escapeType), location)
    case RecordConstructorExpression(entries, location) =>
      RecordConstructorExpression(
        entries.map {
          case (name, (expr, location)) =>
            (escapeName(name, location), (findAndEscapeIdentifiers(expr), location))
        },
        location
      )
    case RecordAccessorExpression(name, target, nameLocation, location) =>
      RecordAccessorExpression(escapeName(name, nameLocation), findAndEscapeIdentifiers(target), nameLocation, location)
    case ExternExpression(externName, typ, location) =>
      ExternExpression(externName, escapeType(typ), location)
    case _: StringLiteralExpression | _: IntLiteralExpression | _: FloatLiteralExpression => expr
  }

  /**
   * Replace underscores with double underscores, and any non UAX31-R1 characters
   * with their hex representation as `uXXXX_`.
   * Additionally check if the name ends up being a Rust keyword, and prefix it with 'k_'
   * @param name The name to escape.
   * @param location The location for better error information.
   * @return The escaped name.
   */
  def escapeName(name: String, location: Location): String = {
    val cleanName = name.replace("_", "__").flatMap { c =>
      if (c.isUnicodeIdentifierPart) s"$c" else f"u${c * 1}%04X_"
    }
    if (RUST_KEYWORDS.contains(name)) {
      if (location != Location.unknown) {
        System.err.println(s"$location: Identifier '$name' is a Rust keyword and will be renamed to 'k_$name'")
      }
      s"k_$cleanName"
    } else {
      cleanName
    }
  }

  /**
   * Reverse [[escapeName]], needed for struct display/parsing
   * @param name The name to unescape.
   * @return The original name.
   */
  def unescapeName(name: String): String = {
    val withoutKeywordPrefix = name.replaceAll("k_", "")
    val pattern = "u([0-9A-F]{4})_".r
    val unescapedUnicode =
      pattern.replaceAllIn(withoutKeywordPrefix, unicode => Character.toString(Integer.valueOf(unicode.group(1), 16)))
    unescapedUnicode.replace("__", "_")
  }

  private def escapeIdentifier(id: Identifier): Identifier = {
    id.idOrName match {
      case Ior.Left(name)      => Identifier(Ior.Left(s"${escapeName(name, id.location)}"), id.location)
      case Ior.Right(num)      => Identifier(Ior.Left(s"${num}_"), id.location)
      case Ior.Both(name, num) => Identifier(Ior.Left(s"${escapeName(name, id.location)}_${num}_"), id.location)
    }
  }

  private def escapeType(typ: Type): Type = {
    typ match {
      case InstantiatedType(name, typeArgs, location) =>
        InstantiatedType(escapeName(name, location), typeArgs.map(escapeType), location)
      case TypeParam(name, location) =>
        TypeParam(escapeIdentifier(name), location)
      case FunctionType(typeParams, paramTypes, resultType, location) =>
        FunctionType(
          typeParams.map(escapeIdentifier),
          paramTypes.map { case (evaluation, typ) => (evaluation, escapeType(typ)) },
          escapeType(resultType),
          location
        )
      case RecordType(entries, location) =>
        RecordType(
          entries.map { case (name, (typ, location)) => (escapeName(name, location), (escapeType(typ), location)) },
          location
        )
    }
  }

  /**
   * https://doc.rust-lang.org/reference/keywords.html
   */
  final private val RUST_KEYWORDS = Set(
    /**
     * strict keywords
     */
    /* KW_AS */ "as",
    /* KW_BREAK */ "break",
    /* KW_CONST */ "const",
    /* KW_CONTINUE */ "continue",
    /* KW_CRATE */ "crate",
    /* KW_ELSE */ "else",
    /* KW_ENUM */ "enum",
    /* KW_EXTERN */ "extern",
    /* KW_FALSE */ "false",
    /* KW_FN */ "fn",
    /* KW_FOR */ "for",
    /* KW_IF */ "if",
    /* KW_IMPL */ "impl",
    /* KW_IN */ "in",
    /* KW_LET */ "let",
    /* KW_LOOP */ "loop",
    /* KW_MATCH */ "match",
    /* KW_MOD */ "mod",
    /* KW_MOVE */ "move",
    /* KW_MUT */ "mut",
    /* KW_PUB */ "pub",
    /* KW_REF */ "ref",
    /* KW_RETURN */ "return",
    /* KW_SELFVALUE */ "self",
    /* KW_SELFTYPE */ "Self",
    /* KW_STATIC */ "static",
    /* KW_STRUCT */ "struct",
    /* KW_SUPER */ "super",
    /* KW_TRAIT */ "trait",
    /* KW_TRUE */ "true",
    /* KW_TYPE */ "type",
    /* KW_UNSAFE */ "unsafe",
    /* KW_USE */ "use",
    /* KW_WHERE */ "where",
    /* KW_WHILE */ "while",
    // since Lexer 2018
    /* KW_ASYNC */ "async",
    /* KW_AWAIT */ "await",
    /* KW_DYN */ "dyn",
    /**
     * reserved keywords
     */
    /* KW_ABSTRACT */ "abstract",
    /* KW_BECOME */ "become",
    /* KW_BOX */ "box",
    /* KW_DO */ "do",
    /* KW_FINAL */ "final",
    /* KW_MACRO */ "macro",
    /* KW_OVERRIDE */ "override",
    /* KW_PRIV */ "priv",
    /* KW_TYPEOF */ "typeof",
    /* KW_UNSIZED */ "unsized",
    /* KW_VIRTUAL */ "virtual",
    /* KW_YIELD */ "yield",
    // since Lexer 2018
    /* KW_TRY */ "try"
  )
}
