/*
 * Copyright (c) 2020 Institute of Software Engineering and Programming Languages,
 * University of LÃ¼beck, Germany
 *
 * Modified MIT license:
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this binary (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software and the code which is
 * generated by the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

package de.uni_luebeck.isp.tessla.tessla_compiler

import de.uni_luebeck.isp.tessla.core.TesslaAST.Core._
import de.uni_luebeck.isp.tessla.core.TesslaAST.Core.DefinitionExpression

import scala.collection.mutable

/**
 * Class for calculating a topological sorting on the assignments inside functions and specifications so they
 * can be translated to imperative code
 */
object DefinitionOrdering {

  /**
   * Orders a Map Identifier -> Defining expression to a sequence s.t. every variable is assigned before it is used
   * Exceptions exist for identifiers which have last/delay expressions assigned since they may cause recursions
   * @param input The map Identifier -> Defining to be sorted
   * @return The Identifier -> Defining mappings in an ordered sequence
   */
  def order(input: Map[Identifier, DefinitionExpression]): Seq[(Identifier, DefinitionExpression)] = {

    val ordered: mutable.ArrayBuffer[(Identifier, DefinitionExpression)] = mutable.ArrayBuffer()

    def calcExpressionDependencies(exp: ExpressionArg, ignore: Set[Identifier]): Unit = {
      exp match {
        case ApplicationExpression(TypeApplicationExpression(ExternExpression("last", _, _), _, _), args, _) =>
          calcExpressionDependencies(args(1), ignore)
        case ApplicationExpression(TypeApplicationExpression(ExternExpression("delay", _, _), _, _), args, _) =>
          calcExpressionDependencies(args(1), ignore)
        case ApplicationExpression(app, args, _) =>
          args.appended(app).foreach(exp => calcExpressionDependencies(exp, ignore))
        case ExpressionRef(id, _, _) if input.contains(id) => calcMissingDependencies(id, input(id), ignore)
        case TypeApplicationExpression(e, _, _)            => calcExpressionDependencies(e, ignore)
        case RecordConstructorExpression(entries, _) =>
          entries.foreach { case (_, (exp, _)) => calcExpressionDependencies(exp, ignore) }
        case RecordAccessorExpression(_, target, _, _) => calcExpressionDependencies(target, ignore)
        case _                                         => ()
      }
    }

    def calcMissingDependencies(id: Identifier, dExp: DefinitionExpression, ignore: Set[Identifier]): Unit = {
      if (!ignore.contains(id) && !ordered.contains((id, dExp))) {
        calcExpressionDependencies(dExp, ignore + id)
        ordered += ((id, dExp))
      }
    }

    input.foreach { case (i, d) => calcMissingDependencies(i, d, Set()) }

    ordered.toSeq
  }

}
