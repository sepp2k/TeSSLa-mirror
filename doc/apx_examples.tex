\section{Examples}

\tessla specification formally describes transformations of input to output streams where the set of input streams is defined implicitly by names occurring freely in the specification. 
In practice, however, a more specific control over the inputs is desired and therefore implementations may provide specific input functions, that only depend on constants, e.g., strings describing the stream source.

In the following examples we assume input functions
\begin{align*}
 \mathtt{function\_calls}&: \mathtt{String} â†’ ğ“”_D\\
 \mathtt{function\_returns}&: \mathtt{String} â†’ ğ“”_D\\
\mathtt{instruction\_executions}&:\mathtt{String} â†’ ğ“”_D
\end{align*}
Similarly, the representation of time (intervals) is implementation dependent.
In the example specification we use integer numbers and suffixes (us, ms, s) to indicate appropriate factors. 
Ideally, an implementation will convert, e.g.,  $1s$, $1ms$ and $1us$, into a representation of 1 second, 1 millisecond and 1 microsecond, respectively.

Double hyphens (\texttt{--}) indicate commentary until line ending.

\subsection{Delay}

Property: Whenever an event \emph{source\_event} occurs, within the next 1.2 seconds the next event \emph{target\_event} must occur.
A \emph{target\_event} can serve for multiple \emph{source\_event} occurrences.

\subsubsection{Delay using SALT}

\begin{lstlisting}[language=tessla+salt]
define source_event := function_calls("main.c:open_door")
define target_event := function_returns("main.c:open_door")

define monitor_output := monitor("
  always (if p1 then next timed[<= 1200] p2)",
  source_event,
  target_event
)

out monitor_output
\end{lstlisting}

%\subsubsection{Delay with SALT and macros}
%
%\begin{lstlisting}[language=tessla+salt]
%define delay_constraint(source, target, bounds) :=
%    monitor(always (if {source} then next timed[bounds] target))
%
%out delay_constraint(on entry open_door, on exit close_door, <= 1200)
%\end{lstlisting}

\subsubsection{Delay using SALT without real time operators}

\begin{lstlisting}[language=tessla+salt]
define source_event := function_calls("main.c:open_door")
define target_event := function_returns("main.c:open_door")

define monitor_output := monitor("
  always (if p1 then p2)",
  source_event,
  inFuture(1200ms, target_event)
)

out monitor_output
\end{lstlisting}

\subsection{Strong Delay and Order}

Property: For every \emph{source\_event} a matching \emph{target\_event} must occur within the next 1.2 seconds.
Every \emph{target\_event} is associated to at most one \emph{source\_event}.

\begin{lstlisting}[language=tessla+salt]
define source_event := function_calls("main.c:open_door")
define target_event := function_returns("main.c:open_door")

define event_pairs := synchronize(source_event, target_event, 1200ms)
define error := timeout(event_pairs)

out error
\end{lstlisting}

\subsection{Synchronization}

Property: Whenever an event occurs, all other events have to occur also within a range of 1.2 seconds. 

\subsubsection{Synchronization using SALT}

\begin{lstlisting}[language=tessla+salt]
define event_a := instruction_executions("test.c:23")
define event_b := instruction_executions("test.c:42")
define event_c := instruction_executions("test.c:1729")

define monitor_output := monitor("
  always (
    (if p1 then (next timed[<= 1200] p2 or previous timed[< 1200] p2)) and
    (if p1 then (next timed[<= 1200] p3 or previous timed[< 1200] p3)) and
    (if p2 then (next timed[<= 1200] p1 or previous timed[< 1200] p1)) and
    (if p2 then (next timed[<= 1200] p3 or previous timed[< 1200] p3)) and
    (if p3 then (next timed[<= 1200] p1 or previous timed[< 1200] p1)) and
    (if p3 then (next timed[<= 1200] p2 or previous timed[< 1200] p2)))", 
  event_a, 
  event_b, 
  event_c
)

out monitor_output
\end{lstlisting}

\subsubsection{Synchronization using SALT without real time operators}

\begin{lstlisting}[language=tessla+salt]
define event_a := instruction_executions("test.c:23")
define event_b := instruction_executions("test.c:42")
define event_c := instruction_executions("test.c:1729")

define monitor_output := monitor("
  always (
    (if p1 then p5) and
    (if p1 then p6) and
    (if p2 then p4) and
    (if p2 then p6) and
    (if p3 then p4) and
    (if p3 then p5))",
  event_a,
  event_b,
  event_c,
  within(-1200ms, 1200ms,event_a),
  within(-1200ms, 1200ms,event_b),
  within(-1200ms, 1200ms,event_c)
)

out monitor_output
\end{lstlisting}

\subsection{Periodic}

Property: There exists an event that occurs periodically (period\_event). Whenever period\_event occurs, 
an event (event) has to occurs after at most one second. Between the occurrence of event have to be at least 0.7 seconds.

\subsubsection{Periodic using SALT}

\begin{lstlisting}[language=tessla+salt]
define periodic_event := instruction_executions("test.c:34653")
define event := instruction_executions("test.c:242")

define monitor_output := monitor("
  always (
    (if p1 then next timed[<= 1000] p2) and 
    (if p2 then not(next timed[<= 700] p1)))",
  period_event,
  event
)

out monitor_output
\end{lstlisting}

%\subsubsection{Periodic with SALT and Macro}

%\begin{lstlisting}[language=tessla+salt]
%define periodic_event := on breakpoint test.c:34653
%define event := on breakpoint test.c:242

%define periodic(period,e,jitter,bound) := 
%    monitor(always((if {period} then next timed[<= jitter] e)
%	    and (if {e} then not(next timed[< bound] e))))

%out periodic(periodic_event,event,1000,700)
%\end{lstlisting}


\subsubsection{Periodic using SALT without real time operators}

\begin{lstlisting}[language=tessla+salt]
define periodic_event := instruction_executions("test.c:34653")
define event := instruction_executions("test.c:242")

define monitor_output := monitor("
  always (
    (if p1 then p3) and 
    (if p2 then not(p4)))",
    period_event,
    event,
    inFuture(1000ms,event),
    inFuture(700ms,event)
)

out monitor_output
\end{lstlisting}

\subsection{Use Cases D1-D4}

\subsubsection{Use Case D1 - Simple Saftey Constraint}

Assume an input stream, generated by the application. 
Only values from the range 0-10 are supposed to occur.

\begin{lstlisting}[language=tessla+salt]
 define error := on changeOf(APPL_MSG_Value) if geq(APPL_MSG_Value, 11)
 out error
\end{lstlisting}

\subsubsection{Use Case D2 - Timing Constraints}

Assume an input (events) A and B.

Property D2.1: Event B must not occur within 500ms after any occurrence of event A.
\begin{lstlisting}[language=tessla+salt]
  define error := on A if inFuture(500ms, B)
  out error
\end{lstlisting}

Alternative:
\begin{lstlisting}[language=tessla+salt]
  define error := on B if inPast(500ms, A)
  out error
\end{lstlisting}


A Salt formula $\text{always} (A â†’ Â¬(\text{next timed}[<=500] B))$
\begin{lstlisting}[language=tessla+salt]
  define monitor_output := monitor("always if p1 then not next timed [<=500ms] p2", A, B)
  out monitor_output
\end{lstlisting}

D2.2: In the environment of 500ms around every event A some B must occur
\begin{lstlisting}[language=tessla+salt]
  define error := on A if not(within( -500ms, 500ms, B))
  out error
\end{lstlisting}

\subsubsection{Use Case D3 - Numerical analysis}

Assume as inputs: signals A and B, event stream C

\paragraph{D3.1:} Value exceeds limit of 1023
\begin{lstlisting}[language=tessla+salt]
  define out_of_range := geq(A,1024)
  out out_of_range
\end{lstlisting}

\paragraph{D3.2:} Difference between maximum and minimum value exceeds limit of 1023
\begin{lstlisting}[language=tessla+salt]
  define diff := sub(maximum(A),minimum(A))
  out geq(diff,1024)
\end{lstlisting}

\paragraph{D3.3:} Values of events C deviate at most by 1023 from their mean
%Unbiased estimation of standard deviation:
%\begin{lstlisting}
%  define error 33 := count(A) > 1  && sqrt( (sum(A**2) - ( (sum(A)**2)/count(A) )) / (count(A)-1)) ) > 1023
%\end{lstlisting}
%Maximal difference to mean:
\begin{lstlisting}[language=tessla+salt]
define mean := div(sum(C),max(eventCount(C),1))
    -- assumes implicit initialisation event with value 0
define diffMax := sub(maximum(C, 0), mean)
define diffMean := sub(mean, maximum(C, 0))
define out_of_range := or(geq(diffMax,1024),geq(diffMean,1024))
out on changeOf(out_of_range) if out_of_range
\end{lstlisting}

\paragraph{D3.4:} Error if value of C diverges by more than 1023 from moving average of previous 10 values
\begin{lstlisting}[language=tessla+salt]
define assertion := leq(abs(sub(C,sma(C, 10))),1024)
define error := on changeOf(assertion) if not(assertion)
out error
\end{lstlisting}
