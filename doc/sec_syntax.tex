\section{Syntax}

This section describes the syntax of \tessla.

\subsection{Basic Syntax}

The basic syntax of \tessla specifications is given by the following grammar.

\begin{align*}
  spec \text{ ::= } &\textttbf{define } name[\textttbf{:}\ stype] \textttbf{ := } texpr ÔΩú\\
                    & \textttbf{out } texpr ÔΩú 
                    spec\ spec\\
% name \text{ ::= }  & [\textttbf{A}-\textttbf{z}][\textttbf{A}-\textttbf{z0}-\textttbf{9\_}]^*
  texpr \text{ := } & expr[\textttbf{:}\ type] \\
  expr \text{ := }  & name \mid literal \mid name\textttbf{(}texpr(\textttbf{, }texpr)^*\textttbf{)}\\
  type \text{ := } & btype \mid stype \\
  stype \text{ := } & \textttbf{Signal<}btype\textttbf{>} \mid \textttbf{Events<}btype\textttbf{>}
\end{align*}

Names are nonempty strings $name‚ààAB^*$ where $A=\{\textttbf{A},‚Ä¶,\textttbf{Z},\textttbf{a},‚Ä¶,\textttbf{z}\} $ are the alphanumeric characters and $B = A‚à™\{\textttbf{\_}\}$.
Basic types $btype$ cover typical ones such as \textttbf{Int}, \textttbf{Float}, \textttbf{String} or \textttbf{Bool}.
Literals $literal$ denote explicit values, of basic types, such as integers $-1,0,1,2,‚Ä¶$, floating point numbers $0.1, -3.141593$ or strings (enclosed in double quotes). 
Available basic types and literal representation are implementation dependent.

\subsection{Syntactical Extensions}

For convenience, we consider three additional syntactical elements: \textttbf{on}\emph{-comprehensions}, \emph{infix notation for binary operators} and \emph{named arguments}.

\subsubsection{On-comprehension}

Syntax:
\begin{align*}
  oncomp   &::= \textttbf{on } triggers [\textttbf{ if } filterExpr] [\textttbf{ yield } valueExpr] \\
  triggers &::= name(\textttbf{, } name)^*
\end{align*}

The $triggers$ are a list of names denoting event streams. 
The filtering Expression $filterExpr$ is an expression of type \textttbf{Signal<Bool>} where every free name either occurs in the trigger list or denotes a signal. 
Intuitively, the on-comprehension emits an event at those time points $t‚ààùïã$ where all of the trigger streams emit an event (i.e., are defined) and the filter signal has value \textttbf{true}.
If the \textttbf{yield} part is omitted, the events do not carry a value, i.e., the stream is of type \textttbf{Events<Unit>}. 
Otherwise, the value expression $valueExpr$ defines the value of every event. 
As for the filter expression, it can only contain free names that either occur in the trigger list or are signals.

All functions used in the filter and value expressions are further required to be stateless.

\subsubsection{Named Arguments}

as expected

\subsubsection{Infix Operators}

as expected

