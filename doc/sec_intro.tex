\section{Introduction}

%Outline
%
%\begin{enumerate}
%  \item purpose, motivation
%  \begin{itemize}
%    \item online processing of data
%    \item monitoring of trace properties, specifically execution traces of programs
%    \item Functional reactive programming as related concept
%  \end{itemize}
%  \item What you describe with a \tessla specification
%  \begin{itemize}    
%    \item input, output streams
%    \item application of functions, composition of function
%    \item 
%  \end{itemize}
%  \item Modelling data in terms of streams
%  \begin{itemize}
%    \item timing model ($â„$,$â„•$,$â„š$,â€¦), restrictions to streams with discrete set of time stamps (event streams) or peace-wise constant streams (continuous stream)
%    \item continuous streams and event streams    
%   \end{itemize}
%   \item Functions on streams and desired properties (in general)
%   \begin{itemize}
%     \item small examples
%     \item causality, statefulness, time invariance 
%     \item (composition lemmata)
%   \end{itemize}
%   \item \tessla syntax
%   \begin{itemize}
%      \item base grammar with functions and type annotations
%      \item syntactical extensions: infix operators, named arguments, the â€œonâ€
%   \end{itemize}
%   \item Types
%   \begin{itemize}
%     \item Generic types
%     \item Coercion 
%   \end{itemize}
%   \item Functional semantics of operators, small examples
%   \item Larger example/case study
%   \begin{itemize}
%     \item producer/consumer, ring buffer, â€¦
%   \end{itemize}
%   
%   
%\end{enumerate}


Purpose of \tessla.

\begin{itemize}
  \item analysis of trace data
  \item specification of failure patterns, correctness properties, transformations
  \item intuitive, pragmatic means of formulation 
\end{itemize}

Purpose of this document.
\begin{itemize}
  \item Motivate and describe the language
  \item reference
  \item case study and examples from the targeted application area
  \item description of how to integrate runtime verification methodology based on tessla and its implementation into the development process
\end{itemize}

Approach
  \begin{itemize}
    \item online processing of data
    \item monitoring of trace properties, specifically execution traces of programs
    \item Functional reactive programming as related concept
  \end{itemize}
  
\subsection{The Setting}

\tessla is developed in the scope of the CONIRAS project as a language for specifying properties of multicore systems. The goal is to observe the execution of C programs on multicore systems with the processor's debug interfaces and check if these executions fulfill a certain correctness property specified in \tessla. The correctness properties are synthesized as a monitor on an FPGA which also gets the data from the debug interfaces and then the FPGA can check if the properties are violated of satisfied.  

The workflow for creating a monitor from a \tessla specification and to monitor a C program is given in Figure \ref{fig:workflow}. At first the observable points, called tracepoints, have to be extracted from the compiled C code with debug symbols. Tracepoints can be various lines in the assembler code, for example jumps, a write to a variable or similar things. These tracepoints are needed in \tessla specifications to relate to certain lines in the C code and thus they are also needed for the \tessla-compiler such that it knows which lines of code in the C program can be observed when they are reached during execution. After a \tessla specification is compiled the compiler outputs a directed acyclic graph (DAG) which contains all the functions and constants used in the specification. Afterwards, this DAG is synthesized on the FPGA to work as a monitor. The data which the monitor works on comes from the debug interfaces of the CPU. Besides the information about which operation was executed, the data contains timestamps and an ownership ID which relates to the core that executed the operation. But before giving the data into the monitor engine on the FPGA the interesting points have to be reconstructed. Therefore an Instruction Reconstruction (IR) unit is synthesized on the FPGA in front of the monitor engine, hence all data that comes out of the CPU debug interface first goes through this IR unit. The IR unit matches the incoming data to the interesting points described as tracepoints before and sends an event to the monitor engine every time a tracepoint was executed by the CPU. All the data that does not related to a tracepoint or does not contain general important information will be filtered out by the IR unit to reduce the amount of data that reaches the monitor.

\begin{figure}
	\input{fig_workflow}
	\caption{The workflow for reconstructing the program sequence and synthesizing the monitor for a \tessla specification. \label{fig:workflow}} 
\end{figure}

\subsection{The Design of \tessla}

Various requirements lead to the form \tessla has now. Some requirements directly result from setting: because the clock speed of the FPGA is much lower than the one of the CPU cores, an asynchronous processing of the incoming data is necessary which leads to the model of asynchronous streams used in \tessla. Otherwise the FPGA would have an enormous performance overhead. Another requirement that leads to asynchronizity is the fact that we want to verify multicore systems and hence data comes in from multiple cores in an arbitrary order and arbitrarily often (really?) (recursion, Philip?).

Besides the requirements that result directly from the setting, there are different requirements which come from the properties that should be specifiable. By viewing the TIMMO specification language used in the AUTOSAR project it becomes clear that real time constraints are really important in the scope of multicore systems. Among others this includes properties like \textit{every time an event $e_1$ occurs, at most $n$ seconds after (before respectively) $e_1$ another event $e_2$ has to occur}. This results in functions being available in \tessla that work on real time units.

Other important properties of program executions on CPUs require to count events that are happening and also to apply different arithmetic operations on the counted values. This is needed to recognize buffer overflows, check fairness properties on, for example, variables access or resource usage, prove constraints on the number of function calls in the C code and other properties. Another use case for arithmetics is to make calculations on variable values, for example medians. These are typical properties that are interesting for the industry and hence to be able to specify those properties, \tessla needs arithmetic functions.

Not only but also because of the necessity of counting events, it is necessary to apply operations directly on the input streams. These can transform the data of the events of an input stream or can even add or take out whole events. Typical examples for these operations are if-then constructs or filter and merge functions which are needed in \tessla.

Another important aspect is possibility to use other well known state-based languages within \tessla. user acceptance and efficiency of STMs
  
\subsection{What you describe with a \tessla specification}

\tessla is conceptually based on streams as a model for data processing and data analysis. 
The data to be analysed is considered as input streams and a \tessla specification essentially describes a set of output streams and how they can be derived from the input.
To this end, new streams can be defined by applying some function to existing ones.
For example, given an input stream of integral values, a \tessla specification could describe the stream that consecutively provides the sum of all previous input values.
This is achieved by applying a corresponding function to the input stream and thereby defining a new output stream.

\subsection{Stream Model}
\label{sec:streams}

\begin{figure}
  \input{fig_streams}
  \caption{Example streams.\label{fig:streams}} 
\end{figure}

The streams used in \tessla specifications model the essential aspects found in computer programs, namely values (e.g., the value of a program variable), events (e.g., the call of a specific function) and time, both, in a qualitative (ordering) and quantitative (duration) sense.

The timing model is based on time stamps $tâˆˆğ•‹$ where we assume $ğ•‹$ to be isomorphic to the real numbers $â„$.\footnote{Notice that we deliberately choose \emph{the continuum} as a model of real time as is common in philosophy, physics and engineering. For our purposes of specifying timing property, however, also a weaker notion of density would clearly suffice, such as the rational numbers $â„š$.}
Although on the technical level time is mostly quantised in actual systems, real time is a common and intuitive model.
In fact, neither specification nor evaluation based on single steps of, e.g., the a CPU core are reasonable. 
Time is therefore handled, formally and technically, in terms of intervals.
In the following, we make the notion of streams precise that provide the semantic basis of the language.
We use $ğ•‹$ to denote the time domain to make an explicit distinction between time stamps and, e.g., real values.
This avoids confusion and inconsistencies since the representation of time values is implementation dependent.
For example, the values may be scaled according to the processing clock speed and therefore adding or comparing a value $tâˆˆğ•‹$ with some real value $râˆˆâ„$ is not well defined unless considering a specific execution platform with fixed parameters.
However, we use common operators and symbols to work with time stamps, such as $+$ (addition), $â‰¤$ (ordering) and $0$ (neutral element of addition), that are defined as expected.

We consider two types of streams.
Values, e.g., of a program variable or stored at some specific memory address, might change over time but can be assumed to always be present.
They are represented by continuous streams that we call \emph{signals}. \todo{adde preliminary definitions somewhere, e.g., appendix: piece-wise constant function, segments, intervals, left/right-closed, change points}

\begin{definition}[Signals]
  Let $D$ be a set of data values. 
  A \emph{signal of type $D$} is a function $Ïƒ: ğ•‹_{â‰¥0} â†’ D$ such that
  \begin{itemize}
    \item $Ïƒ$ is piece-wise constant,
    \item every segment $Iâˆˆ\mathsf{seg}(Ïƒ)$ is left-closed\footnote{
          A \emph{segment} of a piece-wise constant function $Ïƒ: ğ•‹_{â‰¥0} â†’ D$ is a maximal interval $IâŠ‚ğ•‹$ with constant value $vâˆˆD$, i.e., $âˆ€_{tâˆˆI}:Ïƒ(t)=v$.} and
    \item the set of change points $Î”(Ïƒ) := ï½›\min Iï½œIâˆˆ\mathsf{seg}(Ïƒ)ï½$ is discrete\footnote{A subset $M$ of $ğ•‹$ is \emph{discrete} if it does not contain bounded infinite subsets.}.
  \end{itemize}
  The set of all signals $Ïƒ: ğ•‹_{â‰¥0} â†’ D$ is denoted $ğ“¢_D$.
\end{definition}

Apart from values that are conveniently modeled to be continuously available, discrete \emph{events}, like function calls, are of interest.
These are modelled by the second type of streams \emph{event streams} that provide values (events) only at specific points in time wheras no information about the time between two consecutive events is available.

\begin{definition}[Event streams]
  For a set $D$ of data values an \emph{event stream of type $D$} is a partial function $Î·: ğ•‹_{â‰¥0} â‡ D$ such that the domain of definition, called the set of \emph{event points} $E(Î·) := \{tâˆˆğ•‹ï½œÎ·(t)âˆˆD \text{ defined}\}$, is discrete.
%
  The set of all event streams $Î·: ğ•‹_{â‰¥0} â‡D$ is denoted $ğ“”_D$.
\end{definition}

For convenience we may write $Î·(t) = âŠ¥$ to denote that $Î·$ is not defined at time point $tâˆˆğ•‹âˆ– E(Î·)$.
To model streams of events that do not carry a value we use a designated type \texttt{Unit}.
Formally, we let $\mathtt{Unit}=ï½›âŠ¤ï½$ be a set with one designated element $âŠ¤$.

The discreteness condition reflects the property of actual systems that time stamps cannot converge because only a bounded number of events can happen within a fixed time period.

In addition to the definition in terms of partial functions, an event stream $Î·âˆˆğ“”_D$ can be naturally represented as a (possibly infinite) sequence $s_Î·=(t_0,Î·(t_0))(t_1,Î·(t_1))â€¦âˆˆ(E(Î·)Ã—D)^âˆ$ ordered by time ($t_i<t_{i+1}$ for $0â‰¤i<|s_Î·|$) and containing all event points (i.e, $ï½›tï½œ(t,v) \text{ occurs on } s_Î·ï½= E(Î·)$).

\subsection{Defining Streams}

\tessla allows for defining streams through function applications.
Such functions can be applied to signal and event streams, as well as constant values.
For example, addition of two (value) streams can be defined as element-wise addition of the values of two signals \texttt{s1} and \texttt{s2}:
\begin{lstlisting}[language=tessla]
  define sum := add(in1, in2)
\end{lstlisting}
Here, $\mathtt{add}: ğ“¢_â„• Ã— ğ“¢_â„• â†’ ğ“¢_â„•$ is a function that maps a pair of signals $\mathtt{in1},\mathtt{in2}âˆˆğ“¢_â„•$ with data domain $â„•$ to the signal representing their sum at every point in time, i.e.,  $\mathtt{sum}(t) = \mathtt{add}(\mathtt{in1}, \mathtt{in2})(t) = \mathtt{in1}(t) + \mathtt{in2}(t)$ for any time point $tâˆˆğ•‹$.

The specification above hence describes a rather simple transformation of two input streams into one output stream.

Regarding evaluation it is reasonable to restrict the functions on streams that can be used in \tessla, depending on their application context.

\begin{definition}[Causality, state, time invariance]
Let $A,B$ be sets of signals or event streams.
A function $f: A â†’ B$ is considered to \emph{respect weak causality} if there is a constant $kâˆˆğ•‹$ such that $f(Ïƒ)(t)$ is independent of the values $Ïƒ(t')$ for $t'>t+k$:
for all $tâˆˆğ•‹$ and all $Ïƒ,Ïƒ'âˆˆA$ we require that $f(Ïƒ)(t) = f(Ïƒ')(t)$ if $Ïƒ(t')=Ïƒ'(t')$ for all $t'<t+k$.

The function $f$ is called \emph{stateless} if for all $tâˆˆğ•‹$ and all $Ïƒ,Ïƒ'âˆˆA$ we have $f(Ïƒ)(t) = f(Ïƒ')(t)$ if $Ïƒ(t) = Ïƒ'(t)$.

A stateless function $f$ is called \emph{time invariant} if $Ïƒ(t) = Ïƒ(t')$ implies that $f(Ïƒ)(t) = f(Ïƒ)(t')$ for all $ÏƒâˆˆA$ and all $tâˆˆğ•‹_{â‰¥0}$.
\end{definition}


\idea[inline]{
Example: Detecting a delayed action

Assume the control of a device is supposed to react on an input signal within a specific time bound of 10 microseconds.
The control program receives a signal when the function \texttt{rcv()} is called, needs to process the data and react by calling a function \texttt{react()}.
Given means to observe function calls during the execution of the program\footnote{We will discuss observation approaches in Section~\ref{sec:observation}.} a \tessla specification can be used to formulate the timing constraint.
The calls to \texttt{rcv()} and \texttt{react()} can be considered as input event streams \texttt{rcv} and \texttt{react}.

}