\section{Introduction}

%Outline
%
%\begin{enumerate}
%  \item purpose, motivation
%  \begin{itemize}
%    \item online processing of data
%    \item monitoring of trace properties, specifically execution traces of programs
%    \item Functional reactive programming as related concept
%  \end{itemize}
%  \item What you describe with a \tessla specification
%  \begin{itemize}
%    \item input, output streams
%    \item application of functions, composition of function
%    \item
%  \end{itemize}
%  \item Modelling data in terms of streams
%  \begin{itemize}
%    \item timing model ($ℝ$,$ℕ$,$ℚ$,…), restrictions to streams with discrete set of time stamps (event streams) or peace-wise constant streams (continuous stream)
%    \item continuous streams and event streams
%   \end{itemize}
%   \item Functions on streams and desired properties (in general)
%   \begin{itemize}
%     \item small examples
%     \item causality, statefulness, time invariance
%     \item (composition lemmata)
%   \end{itemize}
%   \item \tessla syntax
%   \begin{itemize}
%      \item base grammar with functions and type annotations
%      \item syntactical extensions: infix operators, named arguments, the “on”
%   \end{itemize}
%   \item Types
%   \begin{itemize}
%     \item Generic types
%     \item Coercion
%   \end{itemize}
%   \item Functional semantics of operators, small examples
%   \item Larger example/case study
%   \begin{itemize}
%     \item producer/consumer, ring buffer, …
%   \end{itemize}
%
%
%\end{enumerate}


%Purpose of \tessla.

%\begin{itemize}
%  \item analysis of trace data
%  \item specification of failure patterns, correctness properties, transformations
%  \item intuitive, pragmatic means of formulation
%\end{itemize}

%Purpose of this document.
%\begin{itemize}
%  \item Motivate and describe the language
%  \item reference
%  \item case study and examples from the targeted application area
%  \item description of how to integrate runtime verification methodology based on tessla and its implementation into the development process
%\end{itemize}

%Approach
%  \begin{itemize}
%    \item online processing of data
%    \item monitoring of trace properties, specifically execution traces of programs
%    \item Functional reactive programming as related concept
%  \end{itemize}

\subsection{The Setting}

\tessla is developed in the scope of the CONIRAS project as a language for specifying properties of multicore systems. The goal is to observe the execution of C programs on multicore systems with the processor's debug interfaces and check if these executions fulfill a certain correctness property specified in \tessla. The correctness properties are synthesized as a monitor on an FPGA which also gets the data from the debug interfaces. Then the FPGA can check by using the monitor if the properties are violated of satisfied.

The workflow for creating a monitor from a \tessla specification and to monitor a C program is given in Figure \ref{fig:workflow}. At first the observable points, called tracepoints, have to be extracted from the compiled C code with debug symbols. Tracepoints can be various lines in the assembler code, for example jumps, a write to a variable or similar things. These tracepoints are needed in \tessla specifications to relate to certain lines in the C code and thus they are also needed for the \tessla-compiler such that it knows which lines of code in the C program can be observed when they are reached during execution. After a \tessla specification is compiled the compiler outputs a directed acyclic graph (DAG) which contains all the functions and constants used in the specification. Afterwards, this DAG is synthesized on the FPGA to work as a monitor. The data which the monitor works on comes from the debug interfaces of the CPU. Besides the information about which operation was executed, the data contains timestamps and an ownership ID which relates to the core that executed the operation. But before giving the data into the monitor engine on the FPGA the tracepoints have to be reconstructed. Therefore an Instruction Reconstruction (IR) unit is synthesized on the FPGA in front of the monitor engine, hence all data that comes out of the CPU debug interface first goes through this IR unit. The IR unit matches the incoming data to the tracepoints and sends an event to the monitor engine every time a tracepoint was executed by the CPU. All the data that does not related to a tracepoint or does not contain general important information will be filtered out by the IR unit to reduce the amount of data that reaches the monitor.

\begin{figure}
	\input{fig_workflow}
	\caption{The workflow for reconstructing the program sequence and synthesizing the monitor for a \tessla specification. The blue nodes represent the part needed for the compilation of a \tessla specification, the red node represents the multicore CPU, the green nodes represent the parts that are synthesized on the FPGA and the orange node represents the output of the verification process. \label{fig:workflow}}
\end{figure}

\subsection{The Design of \tessla}

\subsubsection{General Requirements}

Various requirements lead to the form \tessla has now. Some requirements directly result from setting: because the clock speed of the FPGA is much lower than the one of the CPU cores, an asynchronous processing of the incoming data is necessary which leads to the model of asynchronous streams used in \tessla. Furthermore, the fact that the systems under scrutiny are multicore systems and hence data comes from multiple core in arbitrary order and amount fits the model of asynchronous streams well.

\subsubsection{Timing Requirements}

Besides the requirements that result directly from the setting, there are different requirements which come from the properties that should be specifiable. By viewing the TIMMO specification language used in the AUTOSAR project it becomes clear that real time constraints are really important in the scope of multicore systems. Additionally the difference of the timestamps of two events can be arbitrarily small which leads to the need of a continuous time model with the constraint that in a finite time frame only a finite number of events, and thus timestamps, can occur. Otherwise no monitoring is possible because an infinite number of events has to be processed in a finite amount of time.

Among others these include properties like the following:

\begin{enumerate}
	\item \textit{Every time an event $e_1$ occurs, at most $n$ seconds after (before respectively) $e_1$ another event $e_2$ has to occur.}
	\item \textit{For every event in the event stream $E_1$, at most $n$ seconds after (before respectively) an Event has to occur on the stream $E_2$. Every event that occurs on $E_2$ can only be matched to at most one from $E_1$.}
\end{enumerate}

This results in functions being available in \tessla that work on real time units.

\subsubsection{Arithmetic Requirements}

Other important properties of program executions on CPUs require to count events that are happening and also to apply different arithmetic operations on the counted values. This is needed to recognize buffer overflows, check fairness properties on, for example, variables access or resource usage, prove constraints on the number of function calls in the C code and other properties. Another use case for arithmetics is to make calculations on variable values, for example medians.

Among others these include properties like the following:

\begin{enumerate}
	\item \textit{The difference of the number of write events and the number of delete events for a buffer of size 5 should never exceed 5.}
	\item \textit{The median of the ten last values a temperature sensor delivers should never exceed 20.}
\end{enumerate}

These are typical properties that are interesting for the industry and hence to be able to specify those properties, \tessla needs arithmetic functions.

\subsubsection{Stream Operation Requirements}

Not only but also because of the necessity of counting events, it is necessary to apply operations directly on the input streams. These can transform the data of the events of an input stream or can even add or take out whole events. Typical examples for these operations are if-then constructs or filter and merge functions which are needed in \tessla.

Among others these include properties like the following:

\begin{enumerate}
	\item \textit{There exists a system with three cores. Both core one and core two should be able to access a certain resource at least once every ten seconds.}
	\item \textit{A certain threshold value should not be exceeded by a variable more than three times in the last ten values of that variable.}
\end{enumerate}

\subsubsection{Temporal Logic Requirements}

Besides the properties that are mentioned above an important class of properties is missing: the properties that are specifiable with typical temporal logics such as the LTL or SALT. These have proven to be interesting in a lot of systems. Furthermore the different semantics available for such logics are needed to detect final output values and to detect those as soon as possible such that errors are acknowledged very early. To be able to use those logics it has to be possible to transform formulas of these logics into state machines which leads to the need to detect where such logics are used. Because of this it is the easiest way to include them into \tessla in a separated function. Another positive side effect is that state machines can be synthesized and executed extremely efficient on the FPGA monitor engine.

Properties for which temporal logics can be used are the following:

\begin{enumerate}
	\item \textit{When the only process that writes values to the buffer is deactivated, no write operations should happen on the buffer until the process is activated again.}
	\item \textit{Every time $a$ occurs a $b$ has to be occurred 2 to 5 seconds before.}
\end{enumerate}

\subsection{What you describe with a \tessla specification}

\tessla is conceptually based on streams as a model for data processing and data analysis.
The data to be analysed is considered as input streams and a \tessla specification essentially describes a set of output streams and how they can be derived from the input.
To this end, new streams can be defined by applying some function to existing ones.
For example, given an input stream of integral values, a \tessla specification could describe the stream that consecutively provides the sum of all previous input values.
This is achieved by applying a corresponding function to the input stream and thereby defining a new output stream.

\subsection{Stream Model}
\label{sec:streams}

\begin{figure}
  \input{fig_streams}
  \caption{Example streams.\label{fig:streams}}
\end{figure}

The streams used in \tessla specifications model the essential aspects found in computer programs, namely values (e.g., the value of a program variable), events (e.g., the call of a specific function) and time, both, in a qualitative (ordering) and quantitative (duration) sense.

The timing model is based on time stamps $t∈𝕋$ where we assume $𝕋$ to be isomorphic to the real numbers $ℝ$.\footnote{Notice that we deliberately choose \emph{the continuum} as a model of real time as is common in philosophy, physics and engineering. For our purposes of specifying timing property, however, also a weaker notion of density would clearly suffice, such as the rational numbers $ℚ$.}
Although on the technical level time is mostly quantised in actual systems, real time is a common and intuitive model.
In fact, neither specification nor evaluation based on single steps of, e.g., the a CPU core are reasonable.
Time is therefore handled, formally and technically, in terms of intervals.
In the following, we make the notion of streams precise that provide the semantic basis of the language.
We use $𝕋$ to denote the time domain to make an explicit distinction between time stamps and, e.g., real values.
This avoids confusion and inconsistencies since the representation of time values is implementation dependent.
For example, the values may be scaled according to the processing clock speed and therefore adding or comparing a value $t∈𝕋$ with some real value $r∈ℝ$ is not well defined unless considering a specific execution platform with fixed parameters.
However, we use common operators and symbols to work with time stamps, such as $+$ (addition), $≤$ (ordering) and $0$ (neutral element of addition), that are defined as expected.

We consider two types of streams.
Values, e.g., of a program variable or stored at some specific memory address, might change over time but can be assumed to always be present.
They are represented by continuous streams that we call \emph{signals}. \todo{adde preliminary definitions somewhere, e.g., appendix: piece-wise constant function, segments, intervals, left/right-closed, change points}

\begin{definition}[Signals]
  Let $D$ be a set of data values.
  A \emph{signal of type $D$} is a function $σ: 𝕋_{≥0} → D$ such that
  \begin{itemize}
    \item $σ$ is piece-wise constant,
    \item every segment $I∈\mathsf{seg}(σ)$ is left-closed\footnote{
          A \emph{segment} of a piece-wise constant function $σ: 𝕋_{≥0} → D$ is a maximal interval $I⊂𝕋$ with constant value $v∈D$, i.e., $∀_{t∈I}:σ(t)=v$.} and
    \item the set of change points $Δ(σ) := ｛\min I｜I∈\mathsf{seg}(σ)｝$ is discrete\footnote{A subset $M$ of $𝕋$ is \emph{discrete} if it does not contain bounded infinite subsets.}.
  \end{itemize}
  The set of all signals $σ: 𝕋_{≥0} → D$ is denoted $𝓢_D$.
\end{definition}

Apart from values that are conveniently modeled to be continuously available, discrete \emph{events}, like function calls, are of interest.
These are modelled by the second type of streams \emph{event streams} that provide values (events) only at specific points in time wheras no information about the time between two consecutive events is available.

\begin{definition}[Event streams]
  For a set $D$ of data values an \emph{event stream of type $D$} is a partial function $η: 𝕋_{≥0} ⇁ D$ such that the domain of definition, called the set of \emph{event points} $E(η) := \{t∈𝕋｜η(t)∈D \text{ defined}\}$, is discrete.
%
  The set of all event streams $η: 𝕋_{≥0} ⇁D$ is denoted $𝓔_D$.
\end{definition}

For convenience we may write $η(t) = ⊥$ to denote that $η$ is not defined at time point $t∈𝕋∖ E(η)$.
To model streams of events that do not carry a value we use a designated type \texttt{Unit}.
Formally, we let $\mathtt{Unit}=｛⊤｝$ be a set with one designated element $⊤$.

The discreteness condition reflects the property of actual systems that time stamps cannot converge because only a bounded number of events can happen within a fixed time period.

In addition to the definition in terms of partial functions, an event stream $η∈𝓔_D$ can be naturally represented as a (possibly infinite) sequence $s_η=(t_0,η(t_0))(t_1,η(t_1))…∈(E(η)×D)^∞$ ordered by time ($t_i<t_{i+1}$ for $0≤i<|s_η|$) and containing all event points (i.e, $｛t｜(t,v) \text{ occurs on } s_η｝= E(η)$).

\subsection{Defining Streams}

\tessla allows for defining streams through function applications.
Such functions can be applied to signal and event streams, as well as constant values.
For example, addition of two (value) streams can be defined as element-wise addition of the values of two signals \texttt{s1} and \texttt{s2}:
\begin{lstlisting}[language=tessla]
  define sum := add(in1, in2)
\end{lstlisting}
Here, $\mathtt{add}: 𝓢_ℕ × 𝓢_ℕ → 𝓢_ℕ$ is a function that maps a pair of signals $\mathtt{in1},\mathtt{in2}∈𝓢_ℕ$ with data domain $ℕ$ to the signal representing their sum at every point in time, i.e.,  $\mathtt{sum}(t) = \mathtt{add}(\mathtt{in1}, \mathtt{in2})(t) = \mathtt{in1}(t) + \mathtt{in2}(t)$ for any time point $t∈𝕋$.

The specification above hence describes a rather simple transformation of two input streams into one output stream.

Regarding evaluation it is reasonable to restrict the functions on streams that can be used in \tessla, depending on their application context.

\begin{definition}[Causality, state, time invariance]
Let $A,B$ be sets of signals or event streams.
A function $f: A → B$ is considered to \emph{respect weak causality} if there is a constant $k∈𝕋$ such that $f(σ)(t)$ is independent of the values $σ(t')$ for $t'>t+k$:
for all $t∈𝕋$ and all $σ,σ'∈A$ we require that $f(σ)(t) = f(σ')(t)$ if $σ(t')=σ'(t')$ for all $t'<t+k$.

The function $f$ is called \emph{stateless} if for all $t∈𝕋$ and all $σ,σ'∈A$ we have $f(σ)(t) = f(σ')(t)$ if $σ(t) = σ'(t)$.

A stateless function $f$ is called \emph{time invariant} if $σ(t) = σ(t')$ implies that $f(σ)(t) = f(σ)(t')$ for all $σ∈A$ and all $t∈𝕋_{≥0}$.
\end{definition}


\idea[inline]{
Example: Detecting a delayed action

Assume the control of a device is supposed to react on an input signal within a specific time bound of 10 microseconds.
The control program receives a signal when the function \texttt{rcv()} is called, needs to process the data and react by calling a function \texttt{react()}.
Given means to observe function calls during the execution of the program\footnote{We will discuss observation approaches in Section~\ref{sec:observation}.} a \tessla specification can be used to formulate the timing constraint.
The calls to \texttt{rcv()} and \texttt{react()} can be considered as input event streams \texttt{rcv} and \texttt{react}.

}

\subsection{Monitoring Engine}

The \tessla\ compiler translates a specification into a DAG of functions.
This DAG is then synthesized on an FPGA in order to execute such a specification.
On the FPGA both signals and event streams are represented
as tuples of data and timestamps.
In case of signals each value change corresponds to such a tuple.
On the FPGA data and timestamps are transferred through seperated lines
with sufficient bus with.
Data and the corresponding timestamp are always kept in sync.
An $n$-ary function in the DAG is translated into a function block with $n$ data inputs,
one timestamp input, one data output and one timestamp output.
Note that every function block has only one timestamp input,
which may require additional synchronization in front of it:
If you want to combine $n$ not yet synchronized streams in one function block,
a synchronization block is added which takes $n$ value inputs and the corresponding $n$ timestamp inputs
and has $n$ value outputs and only one timestamp output.
This block buffers the incoming values and timestamps until all values for a common timestamp are known,
and then emits one timestamp together with $n$ values.
% TODO: Does this hold for signals and event streams? Can we compute new event streams out of multiple event stream? How?
