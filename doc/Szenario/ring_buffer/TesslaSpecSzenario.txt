Das Szenario beschreibt einen Ringpuffer einer bestimmten Größe der zusätzlich noch einen Moduswechsel durchführen kann. 
Der Ringpuffer selber besitzt einen Producer, der Elemente in den Puffer hineinschreiben kann sowie mehrere Consumer, die diese Elemente in der Reihenfolge, in der sie hineingeschrieben wurden, wieder herauslesen und weiterverarbeiten können.
Ein Moduswechsel schaltet den Modus des Rinpuffers um. Ein Moduswechsel wird durchgeführt, indem zuerst der Producer angehalten wird. Danach wird darauf gewartet, dass alle Consumer ihre aktuellen Aktionen beenden. Nachdem dann angezeigt wurde, dass ein Moduswechsel stattfindet, werden die neuen Consumer gestartet. Darauf folgend wird dann auch der Producer wieder in Betrieb genommen.

Eigenschaften über den Puffer:

Überprüft, ob nicht mehr aus dem Ringpuffer gelesen als hineingeschrieben wird. Sollte mehr gelesen werden, so vergessen Consumer entweder beim Lesen die Elemente zu löschen oder Elemente werden mehrfach hineingeschrieben.

---
define writeElement := instruction_executions("main.c:49")
define processElement := function_calls("main.c:process_data")

define difference := eventCount(processElement) - eventCount(writeElement)
define error := on processElement if geq(difference,1) 

out error
---

Überprüft, dass der Ringpuffer nicht überläuft. Dafür werden die Anzahlen der in der Puffer geschriebenen und aus dem Puffer gelesenen Elemente verglichen. Wir gehen hier von einer Puffergröße von 5 aus.

---
define writeElement := instruction_executions("main.c:49")
define processElement := function_calls("main.c:process_data")

define difference := eventCount(writeElement) - eventCount(processElement)
define bufferOverflow := on writeElement if geq(difference,6)

out bufferOverflow
---

Überprüft, ob die Consumer die Elemente schnell genug verarbeiten, nachdem sie sie aus dem Puffer gelesen haben. Ein Consumer hat 2 Sekunden Zeit, um nach dem Lesen eines Elementes die Verarbeitung eines Elementes abzuschließen. Es wird von drei Consumern C1, C2 und C3 mit den ThreadIDs 1, 2 und 3 ausgegangen.

---
define ids := mrv(ownerships())
define startProcessC1 := on function_calls("main.c:process_data") if equals(ids,1)
define endProcessC1 := on function_returns("main.c:process_data") if equals(ids,1)
define startProcessC2 := on function_calls("main.c:process_data") if equals(ids,2)
define endProcessC2 := on function_returns("main.c:process_data") if equals(ids,2)
define startProcessC3 := on function_calls("main.c:process_data") if equals(ids,3)
define endProcessC3 := on function_returns("main.c:process_data") if equals(ids,3)

define errorC1 := on startProcessC1 if not(inFuture(endProcessC1,2s))
define errorC2 := on startProcessC2 if not(inFuture(endProcessC2,2s))
define errorC3 := on startProcessC3 if not(inFuture(endProcessC3,2s))
define error := merge(merge(errorC1,errorC2),errorC3)

out error
---

Wenn ein Consumer versucht ein Element aus dem Ringpuffer zu lesen, soll nicht zu oft ein anderer Consumer das Element vorher aus dem Puffer herausnehmen. Der Versuch ein Element zu lesen soll mehr als doppelt so oft erfolgreich sein wie er ein Misserfolg ist. Ansonsten würde ein Consumer zu viel Rechenzeit mit dem Versuch verbringen, ein Element zu lesen, ohne es wirklich zu tun. Es wird von drei Consumern C1, C2 und C3 mit den ThreadIDs 1, 2 und 3 ausgegangen.

---
define ids := mrv(ownerships())
define tryC1 := on instruction_executions("main.c:71") if equals(ids,1)
define readC1 := on instruction_executions("main.c:73") if equals(ids,1)
define tryC2 := on instruction_executions("main.c:71") if equals(ids,2)
define readC2 := on instruction_executions("main.c:73") if equals(ids,2)
define tryC3 := on instruction_executions("main.c:71") if equals(ids,3)
define readC3 := on instruction_executions("main.c:73") if equals(ids,3)

define errorC1 := leq(eventCount(readC1),mul(eventCount(tryC1),2))
define errorC2 := leq(eventCount(readC2),mul(eventCount(tryC2),2))
define errorC3 := leq(eventCount(readC3),mul(eventCount(tryC3),2))
define error := or(errorC1,or(errorC2,errorC3))

out error
---

Consumer C1 darf maximal doppelt so viele Elemente aus dem Ringpuffer genommen haben wie die Consumer C2 oder C3. Dies stellt eine Fairnesseigenschaft dar. Es wird von drei Consumern C1, C2 und C3 mit den ThreadIDs 1, 2 und 3 ausgegangen.

---
define ids := mrv(ownerships())
define readC1 := on instruction_executions("main.c:73") if equals(ids,1)
define readC2 := on instruction_executions("main.c:73") if equals(ids,2)
define readC3 := on instruction_executions("main.c:73") if equals(ids,3)

define eventsOfC1 := eventCount(readC1)
define eventsOfC2 := eventCount(readC2)
define eventsOfC3 := eventCount(readC3)

define readNotEnoughEventsC2 := geq(eventsOfC1,mul(eventsOfC2,2))
define readNotEnoughEventsC3 := geq(eventsOfC1,mul(eventsOfC3,2))
define error := on readC1 if or(readNotEnoughEventsC2,readNotEnoughEventsC3)

out error
---

Eigenschaften über den Moduswechsel:

Die Reihenfolge der einzelnen Schritte bei einem Moduswechsel von dem Operation-Modus zum Maintenance-Modus und wieder zurück zum Operation-Modus darf nicht verändert werden. Dies prüft, ob die Schritte für eine Wartung korrekt durchgeführt wurden.

---
define changeMode := instruction_executions("main.c:182")
define stopProducer := function_calls("main.c:stopProducer")
define stopConsumer := function_calls("main.c:stopConsumer")
define startConsumer := function_calls("main.c:startConsumer")
define startProducer := function_calls("main.c:startProducer")

define monitor_output := monitor("
  always (
    p1 implies (
	  not(p3 or p4 or p5) until (p2 and next (
      not(p4 or p5) until (p3 and next (
      not(p5) until p4))))))",
  changeMode,
  stopProducer,
  stopConsumer,
  startConsumer,
  startProducer
)

out monitor_output
---

Ein Moduswechsel von einem Modus in einen anderen darf maximal 1 Sekunde dauern.

---
define startChangeToMaintenance := instruction_executions("main.c:182")
define endChangeToMaintenance := instruction_executions("main.c:192")
define startChangeToOperation := instruction_executions("main.c:176")
define endChangeToOperation := instruction_executions("main.c:179")

define errorChangeToMaintenance := on startChangeToMaintenance if not(inFuture(endChangeToMaintenance,1s))
out errorChangeToMaintenance

define errorChangeToOperation := on startChangeToOperation if not(inFuture(endChangeToOperation,1s))
out errorChangeToOperation
---

Nachdem die Consumer gestoppt wurden, darf der "Readpointer", der auf das nächste, zu lesende Element des Ringpuffers zeigt, nicht mehr verändert werden, bis die Consumer wieder gestartet wurden. Ansonsten würde ein Consumer etwas lesen, obwohl er angehalten sein sollte.

---
define readPointerValues := variable_values("main.c:read_idx")
define stopConsumer := function_calls("main.c:stopConsumer")
define startConsumer := function_calls("main.c:startConsumer")

define readPointerChanged := on changeOf(readPointerValues)

define monitor_output := monitor("
  always(p1 implies (not(p2) until p3))",
  stopConsumer,
  readPointerChanged,
  startConsumer
)

out monitor_output
---
