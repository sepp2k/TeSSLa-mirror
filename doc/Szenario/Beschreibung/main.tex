\documentclass{article}

\usepackage{utf8-math}   % use unicode symbols in tex source
\usepackage[ngerman]{babel}
\usepackage[textsize=small,
%            disable,
color={orange!30},
shadow,
prependcaption]{todonotes}
\usepackage{stmaryrd}             %\boxempty and ⟦ command
\usepackage{xspace} % correct spacing after operators
\usepackage{floatrow}
%\usepackage{accents} % used for double-hat, double-tilde macro
\usepackage{amsmath}
\usepackage{amsthm}

\usepackage{enumerate}
\usepackage{cancel}
\usepackage{microtype}

\usepackage{tikz}
\usetikzlibrary{arrows, matrix, shapes.misc, decorations, decorations.pathreplacing, automata}

%\usepackage{pgfplots}
\usepackage{tikz-timing}

\usepackage{thmtools}
\usepackage{thm-restate}
\usepackage{listings}
\usepackage[lighttt]{lmodern}
%\usepackage{lmodern}

%\usepackage{hyperref}
%\usepackage{cleveref}

\usepackage{fancyhdr}
\title{Deliverable Arbeitspaket 3.8}


%% CONIRAS Deliverable style
\usepackage{fancyhdr}
\newcommand{\thetitle}{(AP\,3.8) Deliverable Arbeitspaket 3.8}
\title{\thetitle}
\pagestyle{fancy}
\setlength{\headheight}{15pt}
\fancyhead[RO]{\thepage}
\fancyhead[LO]{\thetitle}
\fancyfoot[C]{}


\newtheorem{proposition}{Proposition}

\input{macros}
\input{layout}

\begin{document}

\maketitle

In diesem Dokument werden die Testszenarien protokolliert, die zum Testen der Integration der Teilsysteme verwendet wurden. Das erste Testszenario besteht aus einem einfachen Sortieralgorithmus und das zweite aus einem Produzent-Konsument-Kreislauf, in welchem mehrere Threads über einen Ringpuffer kommunizieren.

\section{Sortieralgorithmus}

\subsection{Beschreibung des Szenarios}

Im ersten Testszenario wird ein festes Array mittele Quicksort sortiert. Der Sortiervorgang wird viele Male wiederholt. Das Testszenario ist mit Absicht sehr einfach gehalten, um die generelle Funktion des Gesamtsystems zu testen.
Insbesondere verwendet das Programm keinerlei Bibliotheken.

\subsection{Eigenschaft}

Die Eigenschaft, die für dieses Szenario spezifiziert wurde, beschreibt eine typisches Erwartung an den Quicksort-Algorithmus: Er sollte nach maximal $\frac{n \cdot (n - 1)}{2}$ rekursiven Aufrufen terminieren, wobei $n$ die Länge des Arrays ist, das sortiert werden soll. Die folgende Eigenschaft beschreibt, dass es bei jeder Wiederholung maximal diese Anzahl an Aufrufen geben darf, bis die nächste Wiederholung gestartet wird.

\begin{lstlisting}[language=tessla+salt]
--
-- Macros
--
define onTrue(x) := onIf(changeOf(x), x)

--
-- Inputs
--
define callQS := exec(17) -- call to quick_sort()
define repeat := exec(45) -- start new iteration round

--
-- Spec
--
define callCount := eventCount(callQS, repeat)
define error := onTrue(gt(callCount, constantSignal(div(mul(20,19),2))))
\end{lstlisting}

\section{Ringpuffer}

\subsection{Beschreibung des Szenarios}

Als zweites Testszenario wurde ein Ringpuffer fester Größe (5) betrachtet, in den Elemente geschrieben und aus dem Elemente gelesen und verarbeitet werden. Es gibt genau einen Thread, der als Produzent agiert und Elemente in den Ringpuffer hineinschreiben kann.
Weiterhin gibt es eine (potenziell beliebige) Anzahl an Konsumenten, die Elemente aus dem Ringpuffer lesen und verarbeiten. Die Konsumenten sind ebenfalls als (gleichartige) Threads implementiert und laufen damit parallel zum Produzenten und zueinander.
Der Ringpuffer ist im Haldenspeicher abgelegt und wird über Zeiger referenziert.
Des Weiteren können der Produzent und die Konsumenten durch externe Kontrolleingaben angehalten und wieder gestartet werden.

\subsection{Eigenschaften}

Für dieses Testszenario wurden drei unterschiedliche Eigenschaften spezifiziert, die mögliche Fehler bei der Verwendung des Ringpuffers oder bei der Verarbeitung der Daten beschreiben. Eine Eigenschaft bezieht sich auf die Größe des Puffers, eine auf Echtzeitanforderungen der Verarbeitung sowie eine temporale Eigenschaft über die Kontrolle der Threads.

\subsubsection{Größe des Puffers}

Diese Eigenschaft beschreibt zwei mögliche, ähnliche Fehlerfälle dieses Szenarios. Zum Einen,
dürfen nicht mehr Elemente verarbeitet werden, als in den Ringpuffer geschrieben wurden.
Zum Anderen wird darf die Menge der geschriebenen, aber noch nicht verarbeiteten Elemente die Größe des Puffers nicht überschreiten, da sonst der Puffer überläuft oder, in diesem Szenario, Daten unverarbeitet verworfen (überschrieben) werden.

\begin{lstlisting}[language=tessla+salt]
--
-- Inputs
--
define writeElement := exec(2)    -- write to buffer (pointer)
define processElement := exec(13) -- call to process_data() routine

--
-- Spec
--
define diffProcWrite := sub(eventCount(processElement),
  eventCount(writeElement))
define doubleProcessing := onIf(processElement,
  geq(diffProcWrite,constantSignal(1)))

define diffWriteProc := sub(eventCount(writeElement),
  eventCount(processElement))
define bufferOverflow := onIf(writeElement,
  geq(diffWriteProc,constantSignal(6)))
\end{lstlisting}

Diese die folgenden Spezifikationen verwendet eine Präfixnotation für das \texttt{on-if-yield}-Konstrukt, da Infixnotation im Prototypen des Compilers bisher nicht realisiert wurde.

\subsubsection{Verarbeitungszeit}

Diese Eigenschaft beschreibt, dass die Verarbeitungszeit eines Konsumenten für ein Element nicht mehr als zwei Sekunden beträgt.
Dafür wird die Zeit zwischen dem Aufruf der Verarbeitungsmethode und dessen Rückgabe betrachtet. Es wird zunächst davon ausgegangen, dass es höchstens drei Konsumenten gibt.

\begin{lstlisting}[language=tessla+salt]
--
-- Macros
--
define sample(s, e) := ifThen(e, s)
define onTrue(x) := onIf(changeOf(x), x)

--
-- Inputs
--
define startC1 := onIfYield(exec(1),
  eq(threadID, constantSignal(1)), constantSignal(true))
define startC2 := onIfYield(exec(1),
  eq(threadID, constantSignal(2)), constantSignal(true))
define startC3 := onIfYield(exec(1),
  eq(threadID, constantSignal(3)), constantSignal(true))
define endC1 := onIfYield(exec(1),
  eq(threadID, constantSignal(1)), constantSignal(false))
define endC2 := onIfYield(exec(1),
  eq(threadID, constantSignal(2)), constantSignal(false))
define endC3 := onIfYield(exec(1),
  eq(threadID, constantSignal(3)), constantSignal(false))

--
-- Spec
--
define errorC1 := onIf(endC1, not(inPast(2000, startC1)))
define errorC2 := onIf(endC2, not(inPast(2000, startC2)))
define errorC3 := onIf(endC3, not(inPast(2000, startC3)))

define error := merge(merge(errorC1,errorC2),errorC3)
\end{lstlisting}

\subsubsection{Anhalten der Consumer}

Diese Eigenschaft beschreibt das korrekte Verhalten, wenn die Konsumenten angehalten und danach wieder gestartet werden.
Sobald die Konsumenten angehalten wurden, darf der Lesezeiger für den Ringpuffer nicht verändert werden, bis diese wieder gestartet wurden. Ansonsten würden die Konsumenten aus dem Ringpuffer lesen, obwohl sie angehalten wurden.

\begin{lstlisting}[language=tessla+salt]
--
-- Macros
--
define prop(e1,e2) := mrv(merge(ifThen(e1, constantSignal(true)),
  ifThen(e2, constantSignal(false))), false)

--
-- Input
--
define readPointerChanged := exec(1)
define stopConsumer := exec(2)
define startConsumer := exec(3)

--
-- Spec
--
define clk := occursAny(occursAny(stopConsumer, readPointerChanged),
  startConsumer)
define stop := prop(stopConsumer, clk)
define start := prop(startConsumer, clk)
define change := prop(readPointerChanged, clk)

define monitor_output := monitor(
  "always(p1 implies (not(p2) until p3))",
  p1 := stop,
  p2 := change,
  p3 := start,
  clock := clk
)
\end{lstlisting}


\end{document}
