\section{Semantics}

The formal semantics of a \tessla specification is a function mapping a set of input streams to a set of output streams.

The set of output streams consists of all streams that are explicitly defined in the specification.
The set of input streams is defined implicitly by the set of names (and their type) denoting a stream that occur freely in the specification, i.e., without definition.

That way, the semantics of the specification is build from (and depends on) the semantics of the functions used in the specification.
In the following we describe a set of convenient functions that could be considered as a â€standard libraryâ€œ.

\subsection{Lifted Functions}

A function $f: D_1 Ã— â€¦ Ã— D_n â†’ D_{n+1}$ on basic types can easily be lifted to a function $\hat{f}: ğ“¢_{D_1} Ã— â€¦ Ã— ğ“¢_{D_n} â†’ ğ“¢_{D_{n+1}}$ on signal with $\hat{f}(Ïƒ_1,â€¦,Ïƒ_n)(t) = f(Ïƒ_1(t),â€¦,Ïƒ_n(t))$ for all $tâˆˆğ•‹$.
This is possible since signals provide a value at every time point. 

We list some important lifted functions for arithmetics and boolean operations. 
They are defined as expected in terms of their scalar counterparts as above.

\begin{tabular}{lll}
  Function name, signature & Semantics & Remark\\
  \hline
  $\textttbf{add}: ğ“¢_D Ã— ğ“¢_D â†’ ğ“¢_D$ & $\textttbf{add}(Ïƒ_1,Ïƒ_2)(t) := Ïƒ_1(t) + Ïƒ_2(t)$ & $Dâˆˆ\{â„•,â„¤,â„\}$\\
  $\textttbf{sub}: ğ“¢_D Ã— ğ“¢_D â†’ ğ“¢_D$ & $\textttbf{sub}(Ïƒ_1,Ïƒ_2)(t) := Ïƒ_1(t) - Ïƒ_2(t)$ & $Dâˆˆ\{â„¤,â„\}$\\
  $\textttbf{mul}: ğ“¢_D Ã— ğ“¢_D â†’ ğ“¢_D$ & $\textttbf{mul}(Ïƒ_1,Ïƒ_2)(t) := Ïƒ_1(t) Â· Ïƒ_2(t)$ & $Dâˆˆ\{â„•,â„¤,â„\}$\\
  $\textttbf{geq}: ğ“¢_D Ã— ğ“¢_D â†’ ğ“¢_ğ”¹$ & $\textttbf{geq}(Ïƒ_1,Ïƒ_2)(t) := Ïƒ_1(t) â‰¥ Ïƒ_2(t)$ & $Dâˆˆ\{â„•,â„¤,â„\}$\\
  $\textttbf{leq}: ğ“¢_D Ã— ğ“¢_D â†’ ğ“¢_ğ”¹$ & $\textttbf{leq}(Ïƒ_1,Ïƒ_2)(t) := Ïƒ_1(t) â‰¤ Ïƒ_2(t)$ & $Dâˆˆ\{â„•,â„¤,â„\}$\\
  $\textttbf{eq}: ğ“¢_D Ã— ğ“¢_D â†’ ğ“¢_ğ”¹$ & $\textttbf{eq}(Ïƒ_1,Ïƒ_2)(t) := Ïƒ_1(t) = Ïƒ_2(t)$ & any $D$ with equality\\
  $\textttbf{max}: ğ“¢_D Ã— ğ“¢_D â†’ ğ“¢_D$ & $\textttbf{max}(Ïƒ_1,Ïƒ_2)(t) := \max \{Ïƒ_1(t), Ïƒ_2(t)\}$ & $Dâˆˆ\{â„•,â„¤,â„\}$\\
  $\textttbf{min}: ğ“¢_D Ã— ğ“¢_D â†’ ğ“¢_D$ & $\textttbf{min}(Ïƒ_1,Ïƒ_2)(t) := \min \{Ïƒ_1(t), Ïƒ_2(t)\}$ & $Dâˆˆ\{â„•,â„¤,â„\}$\\
  $\textttbf{and}: ğ“¢_ğ”¹ Ã— ğ“¢_ğ”¹ â†’ ğ“¢_ğ”¹$ & $\textttbf{and}(Ïƒ_1,Ïƒ_2)(t) := Ïƒ_1(t) âˆ§ Ïƒ_2(t)$ & \\
  $\textttbf{or}: ğ“¢_ğ”¹ Ã— ğ“¢_ğ”¹ â†’ ğ“¢_ğ”¹$ & $\textttbf{and}(Ïƒ_1,Ïƒ_2)(t) := Ïƒ_1(t) âˆ¨ Ïƒ_2(t)$ & \\
  $\textttbf{implies}: ğ“¢_ğ”¹ Ã— ğ“¢_ğ”¹ â†’ ğ“¢_ğ”¹$ & $\textttbf{and}(Ïƒ_1,Ïƒ_2)(t) := Ïƒ_1(t) â‡’ Ïƒ_2(t)$ & \\
  $\textttbf{not}: ğ“¢_ğ”¹ â†’ ğ“¢_ğ”¹$ & $\textttbf{not}(Ïƒ_1)(t) := Â¬Ïƒ_1(t)$ &
\end{tabular}


\subsection{Timing Functions}

%Timing functions take a certain number of continuous streams and return a continuous or event stream. The semantics for the timing functions are defined in the following.

The function $\mathtt{delay}$ shifts a stream by a specific amount of time.
We define the function for different signatures and any value domain $D$:
\begin{align*}
  \mathtt{delay}&: ğ“¢_D Ã— ğ•‹ Ã— D â†’ ğ“¢_D 
    & \mathtt{delay}(Ïƒ,d,v)(t) &:= \begin{cases} 
         Ïƒ(t-d) & \text{if } t-dâ‰¥0\\
         v      & \text{otherwise}
       \end{cases}\\
  \mathtt{delay}&: ğ“¢_D Ã— ğ•‹_{â‰¤0} â†’ ğ“¢_D 
    & \mathtt{delay}(Ïƒ,d)(t) &:= Ïƒ(t-d) \\
  \mathtt{delay}&: ğ“”_D Ã— ğ•‹ â†’ ğ“”_D 
      & \mathtt{delay}(Î·,d)(t) &:= \begin{cases} 
           Ïƒ(t-d) & \text{if } t-dâ‰¥0\\
           âŠ¥      & \text{otherwise}
         \end{cases}\\
\end{align*}
The function $\mathtt{timestamp}$ provides the time stamp of an event stream element-wise:
\begin{align*}
  \mathtt{timestamp}&: ğ“”_D â†’ ğ“”_ğ•‹ 
    & \mathtt{timestamp}(Î·)(t) &:= \begin{cases}
        t & \text{if } tâˆˆE(Î·)\\
        âŠ¥ & \text{otherwise}
      \end{cases}
\end{align*}

The function $\mathtt{within}$ serves for checking whether an event occurs within a given (relative) time bound. 
Further functions $\mathtt{inPast}$ and $\mathtt{inFuture}$ can be derived from $within$:
\begin{align*}
  \mathtt{within}&: ğ•‹ Ã— ğ•‹ Ã— ğ“”_D â†’ ğ“¢_ğ”¹ 
    & \mathtt{within}(d_1,d_2,Î·)(t) &:= \begin{cases}
        \mathtt{true} & \text{if } E(Î·)âˆ©[t+d_1,t+d_2]â‰ âˆ…\\        
        \mathtt{false} & \text{otherwise}
      \end{cases}\\
  \mathtt{inPast}&: ğ•‹_{â‰¥0} Ã— ğ“”_D â†’ ğ“¢_ğ”¹ 
    & \mathtt{inPast}(d,Î·)(t) &:= within(-d,0,Î·)(t)\\
  \mathtt{inFuture}&: ğ•‹_{â‰¥0} Ã— ğ“”_D â†’ ğ“¢_ğ”¹ 
    & \mathtt{inFuture}(d,Î·)(t) &:= within(0,d,Î·)(t)
\end{align*}

\todo[inline,nolist]{TODO

The function $\mathtt{synchronise}$ matches events from two streams within a given time range.

\begin{align*}
  \mathtt{synchronise}&: ğ“”_D Ã— ğ“”_D Ã— ğ•‹ â†’ 
\end{align*}
}

\subsection{Aggregations}

For any domain $D$ with linear ordering and addition, respectively, e.g., $â„•,â„¤,â„,â„š$:
 
\begin{align*}
  \mathtt{maximum}&: ğ“”_D Ã— D â†’ ğ“¢_D
    & \mathtt{maximum}(Î·,d)(t) &:= \max (ï½›dï½âˆª\{Î·(t') \mid t'âˆˆE(Î·), t'â‰¤t\})\\
  \mathtt{maximum}&: ğ“¢_D â†’ ğ“¢_D
    & \mathtt{maximum}(Ïƒ)(t) &:= \max \{Î·(t') \mid t'âˆˆğ•‹, t'â‰¤t\} \\
  \mathtt{minimum}&: ğ“”_D Ã— D â†’ ğ“¢_D
    & \mathtt{minimum}(Î·,d)(t) &:= \min (ï½›dï½âˆª\{Î·(t') \mid t'âˆˆE(Î·), t'â‰¤t\})\\
  \mathtt{minimum}&: ğ“¢_D â†’ ğ“¢_D
    & \mathtt{minimum}(Ïƒ)(t) &:= \min \{Î·(t') \mid t'âˆˆğ•‹, t'â‰¤t\}\\
  \mathtt{sum}&: ğ“”_D â†’ ğ“¢_D
    & \mathtt{sum}(Î·)(t) &:= âˆ‘_{t'âˆˆE(Î·)ï½œt'â‰¤t } Î·(t')\\  
\end{align*}

Generic functions $eventCount$ providing the number of occurred events and $mrv$ providing the most recent value of an event stream.

\begin{align*}
  \mathtt{eventCount}&: ğ“”_D â†’ ğ“¢_D
    & \mathtt{eventCount}(Î·)(t) &:= |{t'âˆˆE(Î·)ï½œt'â‰¤t } \\
  \mathtt{mrv}&: ğ“”_D Ã— D â†’ ğ“¢_D
    & \mathtt{mrv}(Î·,d)(t) &:= \begin{cases}
         Î·(\max E(Î·)âˆ©[0,t]) & \text{if } E(Î·)âˆ©[0,t]â‰ âˆ… \\
         d & \text{otherwise}
       \end{cases}
\end{align*}

\subsection{Selectors/Filters/Conditionals/Combinators}

\begin{align*}
  \mathtt{ifThen}&: ğ“”_{D_1} Ã— ğ“¢_{D_2} â†’ ğ“”_{D_2}
      & \mathtt{ifThen}(Î·,Ïƒ)(t) &:= \begin{cases}
           Ïƒ(t) & \text{if } tâˆˆE(Î·)\\
           âŠ¥ & \text{otherwise}
         \end{cases}\\
  \mathtt{ifThenElse}&: ğ“¢_ğ”¹ Ã— ğ“¢_D Ã— ğ“¢_D â†’ ğ“¢_D
      & \mathtt{ifThenElse}(Ïƒ_1,Ïƒ_2,Ïƒ_3)(t) &:= \begin{cases}
           Ïƒ_2(t) & \text{if } Ïƒ_1(t) = \texttt{true}\\
           Ïƒ_3(t) & \text{otherwise}
         \end{cases}\\
  \mathtt{merge}&: ğ“”_D Ã— ğ“”_D â†’ ğ“”_D
      & \mathtt{merge}(Î·_1,Î·_2)(t) &:= \begin{cases}
           Î·_1(t) & \text{if } tâˆˆE(Î·_1)\\
           Î·_2(t) & \text{if } tâˆˆE(Î·_2)âˆ–E(Î·_1)\\
           âŠ¥ & \text{otherwise}
         \end{cases}
\end{align*}
Note that \texttt{ifThen} is a restricted form of an on-comprehension.

\subsection{Monitors}

The monitor function can be used to enable the usage of temporal logics within \tessla. 
A monitor is defined by a temporal logic formula and returns an output value that depends on the evaluation status of the given formula at the current point in time.
We assume that the temporal logic is defined over propositional variables from a fixed and finite set $AP=\{p_1,â€¦,p_n\}$, e.g.\ like LTL.
Further, the semantics is defined on finites words over the alphabet $Î£=2^{AP}$ and admits truth values from some domain $ğ•$ (e.g., $ğ”¹$).
We then let, for arbitrary $D$,
\[
  \texttt{monitor}: TL Ã— (ğ“¢_ğ”¹)^n Ã— ğ“”_D â†’ ğ“”_ğ•
\]
with 
\[
  \texttt{monitor}(Ï†, Ïƒ_1,â€¦,Ïƒ_n,Î·)(t) := \begin{cases}
    âŸ¦w_tâŠ§Ï†âŸ§ & \text{if } tâˆˆE(Î·) \\
    âŠ¥ & \text{otherwise}
   \end{cases}
\]
where $w_t=a_1â€¦a_{|E(Î·)|}$ with $a_i=\{p_kâˆˆAP \mid Ïƒ_k(t_i)=\texttt{true}\}$ for $\{t_1<t_2<â€¦<t_{|E(Î·)|}\} = E(Î·)$.
