\section{Semantics}

The formal semantics of a \tessla specification is a function mapping a set of input streams to a set of output streams.

The set of output streams consists of all streams that are explicitly defined in the specification.
The set of input streams is defined implicitly by the set of names (and their type) denoting a stream that occurs freely in the specification, i.e., without definition.

That way, the semantics of the specification is build from (and depends on) the semantics of the functions used in the specification.
In the following we describe a set of convenient functions that could be considered as a â€standard libraryâ€œ.

\subsection{Lifted Functions}

A function $f: D_1 Ã— â€¦ Ã— D_n â†’ D_{n+1}$ on basic types can easily be lifted to a function $\hat{f}: ğ“¢_{D_1} Ã— â€¦ Ã— ğ“¢_{D_n} â†’ ğ“¢_{D_{n+1}}$ on signals with $\hat{f}(Ïƒ_1,â€¦,Ïƒ_n)(t) = f(Ïƒ_1(t),â€¦,Ïƒ_n(t))$ for all $tâˆˆğ•‹$.
This is possible since signals provide a value at every time point. 

We list some important lifted functions for arithmetics and boolean operations. 
They are defined as expected in terms of their scalar counterparts as above.

\begin{tabular}{lll}
  Function name, signature & Semantics & Remark\\
  \hline
  $\textttbf{add}: ğ“¢_D Ã— ğ“¢_D â†’ ğ“¢_D$ & $\texttt{add}(Ïƒ_1,Ïƒ_2)(t) := Ïƒ_1(t) + Ïƒ_2(t)$ & $Dâˆˆ\{â„•,â„¤,â„\}$\\
  $\texttt{sub}: ğ“¢_D Ã— ğ“¢_D â†’ ğ“¢_D$ & $\texttt{sub}(Ïƒ_1,Ïƒ_2)(t) := Ïƒ_1(t) - Ïƒ_2(t)$ & $Dâˆˆ\{â„¤,â„\}$\\
  $\textttbf{mul}: ğ“¢_D Ã— ğ“¢_D â†’ ğ“¢_D$ & $\texttt{mul}(Ïƒ_1,Ïƒ_2)(t) := Ïƒ_1(t) Â· Ïƒ_2(t)$ & $Dâˆˆ\{â„•,â„¤,â„\}$\\
  $\textttbf{div}: ğ“¢_D Ã— ğ“¢_{D'} â†’ ğ“¢_D$ & $\texttt{div}(Ïƒ_1,Ïƒ_2)(t) := \frac{Ïƒ_1(t)}{Ïƒ_2(t)}$ & $Dâˆˆ\{â„•,â„¤,â„\}, D'=Dâˆ–ï½›0ï½$\\
  $\textttbf{ge}: ğ“¢_D Ã— ğ“¢_D â†’ ğ“¢_ğ”¹$ & $\texttt{ge}(Ïƒ_1,Ïƒ_2)(t) := Ïƒ_1(t) > Ïƒ_2(t)$ & $Dâˆˆ\{â„•,â„¤,â„\}$\\
  $\texttt{geq}: ğ“¢_D Ã— ğ“¢_D â†’ ğ“¢_ğ”¹$ & $\texttt{geq}(Ïƒ_1,Ïƒ_2)(t) := Ïƒ_1(t) â‰¥ Ïƒ_2(t)$ & $Dâˆˆ\{â„•,â„¤,â„\}$\\
  $\texttt{leq}: ğ“¢_D Ã— ğ“¢_D â†’ ğ“¢_ğ”¹$ & $\texttt{leq}(Ïƒ_1,Ïƒ_2)(t) := Ïƒ_1(t) â‰¤ Ïƒ_2(t)$ & $Dâˆˆ\{â„•,â„¤,â„\}$\\
  $\texttt{eq}: ğ“¢_D Ã— ğ“¢_D â†’ ğ“¢_ğ”¹$ & $\texttt{eq}(Ïƒ_1,Ïƒ_2)(t) := Ïƒ_1(t) = Ïƒ_2(t)$ & any $D$ with equality\\
  $\textttbf{max}: ğ“¢_D Ã— ğ“¢_D â†’ ğ“¢_D$ & $\texttt{max}(Ïƒ_1,Ïƒ_2)(t) := \max \{Ïƒ_1(t), Ïƒ_2(t)\}$ & $Dâˆˆ\{â„•,â„¤,â„\}$\\
  $\texttt{min}: ğ“¢_D Ã— ğ“¢_D â†’ ğ“¢_D$ & $\texttt{min}(Ïƒ_1,Ïƒ_2)(t) := \min \{Ïƒ_1(t), Ïƒ_2(t)\}$ & $Dâˆˆ\{â„•,â„¤,â„\}$\\
  $\texttt{abs}: ğ“¢_D â†’ ğ“¢_D$ & $\texttt{abs}(Ïƒ)(t) := |Ïƒ(t)|$ & $Dâˆˆ\{â„•,â„¤,â„\}$\\
  $\texttt{abs}: ğ“”_D â†’ ğ“”_D$ & $\texttt{abs}(Î·)(t) := \begin{cases} |Î·(t)| & \text{if } tâˆˆE(Î·) \\ âŠ¥&\text{otherwise} \end{cases}$&\\
  $\textttbf{and}: ğ“¢_ğ”¹ Ã— ğ“¢_ğ”¹ â†’ ğ“¢_ğ”¹$ & $\texttt{and}(Ïƒ_1,Ïƒ_2)(t) := Ïƒ_1(t) âˆ§ Ïƒ_2(t)$ & \\
  $\texttt{or}: ğ“¢_ğ”¹ Ã— ğ“¢_ğ”¹ â†’ ğ“¢_ğ”¹$ & $\texttt{or}(Ïƒ_1,Ïƒ_2)(t) := Ïƒ_1(t) âˆ¨ Ïƒ_2(t)$ & \\
  $\texttt{implies}: ğ“¢_ğ”¹ Ã— ğ“¢_ğ”¹ â†’ ğ“¢_ğ”¹$ & $\texttt{implies}(Ïƒ_1,Ïƒ_2)(t) := Ïƒ_1(t) â‡’ Ïƒ_2(t)$ & \\
  $\textttbf{not}: ğ“¢_ğ”¹ â†’ ğ“¢_ğ”¹$ & $\texttt{not}(Ïƒ)(t) := Â¬Ïƒ(t)$ &\\
  $\texttt{not}: ğ“”_ğ”¹ â†’ ğ“”_ğ”¹$ & $\texttt{not}(Î·)(t) := \begin{cases} Â¬Î·(t) & \text{if } tâˆˆE(Î·) \\ âŠ¥&\text{otherwise} \end{cases}$&
\end{tabular}


\subsection{Timing Functions}

%Timing functions take a certain number of continuous streams and return a continuous or event stream. The semantics for the timing functions are defined in the following.

The function $\mathtt{delay}$ shifts a stream by a specific amount of time.
We define the function for different signatures and any value domain $D$:
\begin{align*}
  \mathtt{delay}&: ğ“¢_D Ã— ğ•‹ Ã— D â†’ ğ“¢_D 
    & \mathtt{delay}(Ïƒ,d,v)(t) &:= \begin{cases} 
         Ïƒ(t-d) & \text{if } t-dâ‰¥0\\
         v      & \text{otherwise}
       \end{cases}\\
  \mathtt{delay}&: ğ“¢_D Ã— ğ•‹_{â‰¤0} â†’ ğ“¢_D 
    & \mathtt{delay}(Ïƒ,d)(t) &:= Ïƒ(t-d) \\
  \textttbf{delay}&: ğ“”_D Ã— ğ•‹ â†’ ğ“”_D 
      & \mathtt{delay}(Î·,d)(t) &:= \begin{cases} 
           Ïƒ(t-d) & \text{if } t-dâ‰¥0\\
           âŠ¥      & \text{otherwise}
         \end{cases}\\
\end{align*}
Discrete timporal shifts of event streams can be expressed by the functions
\begin{align*}
  \textttbf{delay}&: ğ“”_D â†’ ğ“”_D\\
  \texttt{delay}&: ğ“”_D Ã— â„•_{>0} â†’ ğ“”_D
\end{align*}
defined in terms of the sequence representation $s_Î·$ of event streams $Î·âˆˆğ“”_D$. 
For $s_Î· = (t_0,Î·(t_0))(t_1,Î·(t_1))(t_2,Î·(t_2))â€¦$ we define $\texttt{delay}(s_Î·) := (t_1,Î·(t_0))(t_2,Î·(t_1))â€¦$. 
Notice that in case $|s_Î·|<2$ then $\texttt{delay}(s_Î·)=Îµ$ is empty.
A positive natural argument abbrevates iterated application, i.e., $\texttt{delay}(Î·,n) := \texttt{delay}^n(Î·)$.

The function $\mathtt{timestamp}$ provides the time stamp of an event stream element-wise:
\begin{align*}
  \textttbf{timestamp}&: ğ“”_D â†’ ğ“”_ğ•‹ 
    & \mathtt{timestamp}(Î·)(t) &:= \begin{cases}
        t & \text{if } tâˆˆE(Î·)\\
        âŠ¥ & \text{otherwise}
      \end{cases}
\end{align*}

The function $\mathtt{within}$ serves for checking whether an event occurs within a given (relative) time bound. 
Further functions $\mathtt{inPast}$ and $\mathtt{inFuture}$ can be derived from $within$:
\begin{align*}
  \textttbf{within}&: ğ•‹ Ã— ğ•‹ Ã— ğ“”_D â†’ ğ“¢_ğ”¹ 
    & \mathtt{within}(d_1,d_2,Î·)(t) &:= \begin{cases}
        \mathtt{true} & \text{if } E(Î·)âˆ©[t+d_1,t+d_2]â‰ âˆ…\\        
        \mathtt{false} & \text{otherwise}
      \end{cases}\\
  \mathtt{inPast}&: ğ•‹_{â‰¥0} Ã— ğ“”_D â†’ ğ“¢_ğ”¹ 
    & \mathtt{inPast}(d,Î·)(t) &:= \mathtt{within}(-d,0,Î·)(t)\\
  \mathtt{inFuture}&: ğ•‹_{â‰¥0} Ã— ğ“”_D â†’ ğ“¢_ğ”¹ 
    & \mathtt{inFuture}(d,Î·)(t) &:= \mathtt{within}(0,d,Î·)(t)
\end{align*}

\subsection{Synchronisation}

We define a function $\mathtt{synchronise}$ that matches events from two streams within a given time range.
 \todo{add example or ref appendix}
Its formal signature is defined as
\[
  \textttbf{synchronise}: ğ“”_{D_1} Ã— ğ“”_{D_2} Ã— ğ•‹ â†’ ğ“”_{(D_1+D_2)+(D_1Ã—D_2)}.
\]
Recall that $A+B:= (AÃ—ï½›1ï½)âˆª(BÃ—ï½›2ï½)$\footnote{In programming languages, structures $A+B$ are often represented by a type \texttt{Either<A,B>} with subtypes \texttt{Left<A>} and \texttt{Right<B>} and suitable operations to access the wrapped values of type A and B, respectively (e.g., \texttt{get()}).}.

Since the function takes the temporal relation between the events into account it is most convenient to define its semantics inductively based on the sequence representation.
For $dâˆˆğ•‹_{â‰¥0}$ and sequences $uâˆˆ(ğ•‹_{â‰¥0}Ã—D_1)^âˆ$ and $vâˆˆ(ğ•‹_{â‰¥0}Ã—D_2)^âˆ$ we define the sequence $sync(u,v)$ inductively by 
\[
sync(u,v) = \begin{cases}
  Îµ & \text{if } u=v=Îµ \\
  ((a,1,1),t_1+d) Â· sync(u',v) & \text{if } u=(a,t_1) Â·u' \text{ and } \\
                                   & v=Îµ \text{ or } v=(b,t_2)Â·v' \text{ with } t_2>t_1+d\\
  ((b,2,1),t_2+d) Â· sync(u,v') & \text{if } v=(b,t_2)Â·v' \text{ and } \\
                                   & u=Îµ \text{ or } u=(a,t_1)Â·u' \text{ with } t_1>t_2+d\\
  ((a,b,2),\maxï½›t_1,t_2ï½) Â· f(u',v') & \text{if } u=(a,t_1)Â·u' \text{, } v=(b,t_2)Â·v' \text{ and } |t_1-t_2|â‰¤d
\end{cases}
\]

Based on $sync(u,v)$ we define $\mathtt{synchronise}(Î·_1,Î·_2,d) := Î·_3$ where $Î·_3$ is the event stream defined by the sequence $s_{Î·_3} = sync(s_{Î·_1}, s_{Î·_2})$. 
As defined in Section~\ref{sec:streams}, the sequences $s_{Î·_1}$ and $s_{Î·_2}$ are the sequences representing $Î·_1$ and $Î·_2$, respectively.

For convenience we further define some lifted functions to access the structural information.
\begin{align*}
  \mathtt{getLeft}&: ğ“”_{D_1Ã—D_2} â†’ ğ“”_{D_1}
    & \mathtt{getLeft}(Î·)(t) &:= \begin{cases}
        v_1 & \text{if } tâˆˆE(Î·) \text{ and } Î·(t) = (v_1,v_2)\\
        âŠ¥ & \text{otherwise}
      \end{cases}\\
%
  \mathtt{getRight}&: ğ“”_{D_1Ã—D_2} â†’ ğ“”_{D_2}
    & \mathtt{getRight}(Î·)(t) &:= \begin{cases}
        v_2 & \text{if } tâˆˆE(Î·) \text{ and } Î·(t) = (v_1,v_2)\\
        âŠ¥ & \text{otherwise}
      \end{cases}\\
%      
  \mathtt{getLeft}&: ğ“”_{(D_1+D_2)} â†’ ğ“”_{D_1}
    & \mathtt{getLeft}(Î·)(t) &:= \begin{cases}
        v_1 & \text{if } tâˆˆE(Î·) \text{ and } Î·(t) = (v_1,1)\\
        âŠ¥ & \text{otherwise}
      \end{cases}\\
%
  \mathtt{getRight}&: ğ“”_{(D_1+D_2)} â†’ ğ“”_{D_2}
    & \mathtt{getRight}(Î·)(t) &:= \begin{cases}
        v_2 & \text{if } tâˆˆE(Î·) \text{ and } Î·(t) = (v_2,2)\\
        âŠ¥ & \text{otherwise}
      \end{cases}\\
%
  \mathtt{get}&: ğ“”_{D_1+D_2} â†’ ğ“”_{D_1âˆªD_2}
    & \mathtt{get}(Î·)(t) &:= \begin{cases}
        v & \text{if } tâˆˆE(Î·) \text{ and } Î·(t) = (v,i) \text{ for } iâˆˆï½›1,2ï½\\
        âŠ¥ & \text{otherwise}
      \end{cases}\\
\end{align*}
%
We define a function that indicates whether an event could not be synchronised within the given time bound:
\begin{align*}
  \mathtt{timeout}&: ğ“”_{(D_1+D_2)+(D_1Ã—D_2)} â†’ ğ“”_{ï½›âŠ¤ï½}\\
   \mathtt{timeout}(Î·)(t) & := \begin{cases}
            âŠ¤ & \text{if } tâˆˆE(Î·) \text{ and } Î·(t) = (v,i,1)âˆˆ(D_1+D_2)Ã—ï½›1ï½\\
            âŠ¥ & \text{otherwise}
          \end{cases}\\
\end{align*}
%
A â€œflatâ€ synchronisation simply neglects the origin of a value and gives precedence to the values of the first argument.
\begin{align*}
  &\mathtt{flatSynchronise}: ğ“”_D Ã— ğ“”_D Ã— ğ•‹ â†’ ğ“”_D\\
  &\mathtt{flatSynchronise}(Î·_1,Î·,_2,d)(t) := get(get(\mathtt{synchronise}(Î·_1,Î·_2,d)))
\end{align*}
%
If necessary, we can keep the timeout information.
\begin{align*}
  &\mathtt{flatSynchronise}: ğ“”_D Ã— ğ“”_D Ã— ğ•‹ â†’ ğ“”_{DÃ—ğ”¹} \\
  &\mathtt{flatSynchronise}(Î·_1,Î·,_2,d)(t) := \begin{cases}
        (v,\texttt{true}) & \texttt{if } \mathtt{synchronise}(Î·_1,Î·,2,d)(t) = (v,i,1) \texttt{ for } iâˆˆï½›1,2ï½\\
        (v_1,\texttt{false}) & \texttt{if } \mathtt{synchronise}(Î·_1,Î·,2,d)(t) = (v_1,v_2,2) \\
        âŠ¥ & \texttt{otherwise}
        \end{cases}
\end{align*}

\subsection{Aggregations}

For any domain $D$ with linear ordering and addition, respectively, e.g., $â„•,â„¤,â„,â„š$:
 
\begin{align*}
  \mathtt{maximum}&: ğ“”_D Ã— D â†’ ğ“¢_D
    & \mathtt{maximum}(Î·,d)(t) &:= \max (ï½›dï½âˆª\{Î·(t') \mid t'âˆˆE(Î·), t'â‰¤t\})\\
  \textttbf{maximum}&: ğ“¢_D â†’ ğ“¢_D
    & \mathtt{maximum}(Ïƒ)(t) &:= \max \{Î·(t') \mid t'âˆˆğ•‹, t'â‰¤t\} \\
  \mathtt{minimum}&: ğ“”_D Ã— D â†’ ğ“¢_D
    & \mathtt{minimum}(Î·,d)(t) &:= \min (ï½›dï½âˆª\{Î·(t') \mid t'âˆˆE(Î·), t'â‰¤t\})\\
  \mathtt{minimum}&: ğ“¢_D â†’ ğ“¢_D
    & \mathtt{minimum}(Ïƒ)(t) &:= \min \{Î·(t') \mid t'âˆˆğ•‹, t'â‰¤t\}\\
  \textttbf{sum}&: ğ“”_D â†’ ğ“¢_D
    & \mathtt{sum}(Î·)(t) &:= âˆ‘_{t'âˆˆE(Î·)ï½œt'â‰¤t } Î·(t')\\  
\end{align*}

Generic functions $eventCount$ providing the number of occurred events and $mrv$ providing the most recent value of an event stream.

\begin{align*}
  \textttbf{eventCount}&: ğ“”_D â†’ ğ“¢_D
    & \mathtt{eventCount}(Î·)(t) &:= |{t'âˆˆE(Î·)ï½œt'â‰¤t } \\
  \textttbf{mrv}&: ğ“”_D Ã— D â†’ ğ“¢_D
    & \mathtt{mrv}(Î·,d)(t) &:= \begin{cases}
         Î·(\max E(Î·)âˆ©[0,t]) & \text{if } E(Î·)âˆ©[0,t]â‰ âˆ… \\
         d & \text{otherwise}
       \end{cases}
\end{align*}

We further define the simple moving average on streams of arithmetic type.
Let $\max_1(M) := ï½›\max Mï½$ and $\max_{n+1}(M) := ï½›\max Mï½ âˆª \max_n (Mâˆ–(\max M))$ denote the set of the $n$ largest elements of a linearly ordered set $M$. \todo{move to preliminaries} 
Then, we define the simple moving average $\mathtt{sma}: ğ“”_D Ã— â„•_{>0} â†’ ğ“”_D$ as
\[
   \mathtt{sma}(Î·,n)(t) := \begin{cases}
      \frac{âˆ‘_{t'âˆˆ \max_n ï½›t''âˆˆE(Î·)ï½œt''â‰¤t  ï½} Î·(t')}{|\max_n ï½›t'âˆˆE(Î·)ï½œt'â‰¤t ï½|} & \text{if } tâˆˆE(Î·)\\
      âŠ¥ & \text{otherwise}
    \end{cases}
\]
Notice that for a fixed $n$ we have that 
\begin{lstlisting}[language=tessla,mathescape]
define std_mean_avg := sma(in1, $n$)
out std_mean_avg
\end{lstlisting}
is equivalent to
\begin{lstlisting}[language=tessla,mathescape]
define x$_1$ = in1
define x$_2$ = delay(x$_1$)
define x$_3$ = delay(x$_2$)
...
define x$_n$ = delay(x$(n-1)$)
define sum = add(x$_1$,add($...$add(x$_{n-1}$, x$_n$)$...$))
define std_mean_avg := on x$_n$ yield ifThenElse(sum>0, sum/$n$, 0)
out std_mean_avg
\end{lstlisting}

\subsection{Selectors/Filters/Conditionals/Combinators}

\begin{align*}
  \textttbf{changeOf}&: ğ“¢_{D} â†’ ğ“”_{ï½›âŠ¤ï½}
      & \mathtt{changeOf}(Ïƒ)(t) &:= \begin{cases}
           âŠ¤ & \text{if } tâˆˆÎ”(Ïƒ)\\
           âŠ¥ & \text{otherwise}
         \end{cases}\\
  \textttbf{ifThen}&: ğ“”_{D_1} Ã— ğ“¢_{D_2} â†’ ğ“”_{D_2}
      & \mathtt{ifThen}(Î·,Ïƒ)(t) &:= \begin{cases}
           Ïƒ(t) & \text{if } tâˆˆE(Î·)\\
           âŠ¥ & \text{otherwise}
         \end{cases}\\
  \mathtt{sample}&: ğ“¢_{D_1} Ã— ğ“”_{D_2} â†’ ğ“”_{D_1}
      & \mathtt{sample}(Ïƒ,Î·) &:= \mathtt{ifThen}(Î·,Ïƒ)\\
  \textttbf{filter}&: ğ“”_D Ã— ğ“¢_ğ”¹ â†’ ğ“”_D
      & \mathtt{filter}(Î·,Ïƒ)(t) &:= \begin{cases}
           Î·(t) & \text{if } tâˆˆE(Î·) \\[-0.75ex]
                 & \text{and } Ïƒ(t) = \texttt{true}\\
           âŠ¥ & \text{otherwise}
         \end{cases}\\
  \mathtt{ifThenElse}&: ğ“¢_ğ”¹ Ã— ğ“¢_D Ã— ğ“¢_D â†’ ğ“¢_D
      & \mathtt{ifThenElse}(Ïƒ_1,Ïƒ_2,Ïƒ_3)(t) &:= \begin{cases}
           Ïƒ_2(t) & \text{if } Ïƒ_1(t) = \texttt{true}\\
           Ïƒ_3(t) & \text{otherwise}
         \end{cases}\\
  \mathtt{merge}&: ğ“”_D Ã— ğ“”_D â†’ ğ“”_D
      & \mathtt{occurAny}(Î·_1,Î·_2)(t) &:= \begin{cases}
           Î·_1(t) & \text{if } tâˆˆE(Î·_1)\\
           Î·_2(t) & \text{if } tâˆˆE(Î·_2)âˆ–E(Î·_1)\\
           âŠ¥ & \text{otherwise}
         \end{cases}\\
   \textttbf{occurAny}&: ğ“”_{D_1} Ã— ğ“”_{D_2} â†’ ğ“”_{ï½›âŠ¤ï½}
        & \mathtt{occurAny}(Î·_1,Î·_2)(t) &:= \begin{cases}
             âŠ¤ & \text{if } tâˆˆE(Î·_1)âˆªE(Î·_2)\\
             âŠ¥ & \text{otherwise}
           \end{cases}\\
  \textttbf{occurAll}&: ğ“”_{D_1} Ã— ğ“”_{D_2} â†’ ğ“”_{ï½›âŠ¤ï½}
      & \mathtt{occurAll}(Î·_1,Î·_2)(t) &:= \begin{cases}
           âŠ¤ & \text{if } tâˆˆE(Î·_1)âˆ©E(Î·_2)\\
           âŠ¥ & \text{otherwise}
         \end{cases}
\end{align*}
Notice that \texttt{merge} gives precedence to the first argument and that \texttt{ifThen} is a restricted form of an on-comprehension.

\subsection{Monitors}

The monitor function can be used to enable the usage of temporal logics within \tessla. 
A monitor is defined by a temporal logic formula and returns an output value that depends on the evaluation status of the given formula at the current point in time.
We assume that the temporal logic is defined over propositional variables from a fixed and finite set $AP=\{p_1,â€¦,p_n\}$, e.g.\ like LTL.
Further, the semantics is defined on finite words over the alphabet $Î£=2^{AP}$ and admits truth values from some domain $ğ•$ (e.g., $ğ”¹$).
We then let, for arbitrary $D$,
\[
%  \textttbf{monitor}: TL Ã— (ğ“¢_ğ”¹)^n Ã— ğ“”_D â†’ ğ“”_ğ•
  \textttbf{monitor}: TL Ã— (ğ“¢_ğ”¹âˆªğ“”_âŠ¥)^n  â†’ ğ“”_ğ•
\]
with 
\[
  \texttt{monitor}(Ï†, Ïƒ_1,â€¦,Ïƒ_n,Î·)(t) := \begin{cases}
    âŸ¦w_tâŠ§Ï†âŸ§ & \text{if } tâˆˆE(Î·) \\
    âŠ¥ & \text{otherwise}
   \end{cases}
\]
where $w_t=a_1â€¦a_{m}$ with $a_i=\{p_kâˆˆAP \mid Ïƒ_k(t_i)=\texttt{true}\}$ for $\{t_1<t_2<â€¦<t_{|E(Î·)|}\} = E(Î·)$ and $t_mâ‰¤t<t_{m+1}$.

\idea[inline]{
For practical convenience we could introduce further notation such as where explicit inputs are optionals and instead of fixed propositions $p_1â€¦p_n$ escaped \tessla expressions can be used. For example,

\texttt{monitor("always (p1 implies eventually not p2)", myFunction(in1, in2), in3)}

could be written as

\texttt{monitor "always ( \{myFunction(in1, in2)\}  implies eventually not \{in3\})"}.
}

\subsection{On-comprehension}

Let $Î·_1âˆˆğ“”_{D_1},â€¦,Î·_nâˆˆğ“”_{D_n}$ be event streams, $Ïƒ_{cnd}âˆˆğ“¢_ğ”¹$ a Boolean signal and $Ïƒ_{val}âˆˆğ“¢_D$ a signal of some type $D$.
We define the semantics of on-comprehensions as follows.

\begin{align*}
      âŸ¦\textttbf{on }Î·_1,â€¦,Î·_n  \textttbf{ if } Ïƒ_{cnd} \textttbf{ yield } Ïƒ_{val}âŸ§(t) &:= \begin{cases}
             Ïƒ_{val}(t) & \text{if } tâˆˆâ‹‚_{i=1}^n E(Î·_i)  \text{ and } Ïƒ_{cnd}(t)=\mathtt{true}\\
             âŠ¥ & \text{otherwise}
           \end{cases}\\
\end{align*}
Omitting the \texttt{yield} part amounts to implicitly take $Ïƒ_{val} = Ïƒ_âŠ¤$ where $Ïƒ_âŠ¤: ğ•‹_{â‰¥0} â†’ ï½›âŠ¤ï½$ is the (unique) signal of type \texttt{Unit}.
Omitting the conditional (\texttt{if}) part amount to implicitly take $Ïƒ_{cnd}=Ïƒ_{\mathtt{true}}$ where $Ïƒ_\mathtt{true}: ğ•‹_{â‰¥0} â†’ ï½›\texttt{true}ï½$ is the Boolean signal that is always true.
