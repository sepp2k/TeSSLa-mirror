\section{Semantics}

The formal semantics of a \tessla specification is a function mapping a set of input streams to a set of output streams.

The set of output streams consists of all streams that are explicitly defined in the specification.
The set of input streams is defined implicitly by the set of names (and their type) denoting a stream that occur freely in the specification, i.e., without definition.

That way, the semantics of the specification is build from (and depends on) the semantics of the functions used in the specification.
In the following we describe a set of convenient functions that could be considered as a „standard library“.

\subsection{Lifted Functions}

A function $f: D_1 × … × D_n → D_{n+1}$ on basic types can easily be lifted to a function $\hat{f}: 𝓢_{D_1} × … × 𝓢_{D_n} → 𝓢_{D_{n+1}}$ on signal with $\hat{f}(σ_1,…,σ_n)(t) = f(σ_1(t),…,σ_n(t))$ for all $t∈𝕋$.
This is possible since signals provide a value at every time point. 

We list some important lifted functions for arithmetics and boolean operations. 
They are defined as expected in terms of their scalar counterparts as above.

\begin{tabular}{lll}
  Function name, signature & Semantics & Remark\\
  \hline
  $\textttbf{add}: 𝓢_D × 𝓢_D → 𝓢_D$ & $\textttbf{add}(σ_1,σ_2)(t) := σ_1(t) + σ_2(t)$ & $D∈\{ℕ,ℤ,ℝ\}$\\
  $\textttbf{sub}: 𝓢_D × 𝓢_D → 𝓢_D$ & $\textttbf{sub}(σ_1,σ_2)(t) := σ_1(t) - σ_2(t)$ & $D∈\{ℤ,ℝ\}$\\
  $\textttbf{mul}: 𝓢_D × 𝓢_D → 𝓢_D$ & $\textttbf{mul}(σ_1,σ_2)(t) := σ_1(t) · σ_2(t)$ & $D∈\{ℕ,ℤ,ℝ\}$\\
  $\textttbf{geq}: 𝓢_D × 𝓢_D → 𝓢_𝔹$ & $\textttbf{geq}(σ_1,σ_2)(t) := σ_1(t) ≥ σ_2(t)$ & $D∈\{ℕ,ℤ,ℝ\}$\\
  $\textttbf{leq}: 𝓢_D × 𝓢_D → 𝓢_𝔹$ & $\textttbf{leq}(σ_1,σ_2)(t) := σ_1(t) ≤ σ_2(t)$ & $D∈\{ℕ,ℤ,ℝ\}$\\
  $\textttbf{eq}: 𝓢_D × 𝓢_D → 𝓢_𝔹$ & $\textttbf{eq}(σ_1,σ_2)(t) := σ_1(t) = σ_2(t)$ & any $D$ with equality\\
  $\textttbf{max}: 𝓢_D × 𝓢_D → 𝓢_D$ & $\textttbf{max}(σ_1,σ_2)(t) := \max \{σ_1(t), σ_2(t)\}$ & $D∈\{ℕ,ℤ,ℝ\}$\\
  $\textttbf{min}: 𝓢_D × 𝓢_D → 𝓢_D$ & $\textttbf{min}(σ_1,σ_2)(t) := \min \{σ_1(t), σ_2(t)\}$ & $D∈\{ℕ,ℤ,ℝ\}$\\
  $\textttbf{and}: 𝓢_𝔹 × 𝓢_𝔹 → 𝓢_𝔹$ & $\textttbf{and}(σ_1,σ_2)(t) := σ_1(t) ∧ σ_2(t)$ & \\
  $\textttbf{or}: 𝓢_𝔹 × 𝓢_𝔹 → 𝓢_𝔹$ & $\textttbf{and}(σ_1,σ_2)(t) := σ_1(t) ∨ σ_2(t)$ & \\
  $\textttbf{implies}: 𝓢_𝔹 × 𝓢_𝔹 → 𝓢_𝔹$ & $\textttbf{and}(σ_1,σ_2)(t) := σ_1(t) ⇒ σ_2(t)$ & \\
  $\textttbf{not}: 𝓢_𝔹 → 𝓢_𝔹$ & $\textttbf{not}(σ_1)(t) := ¬σ_1(t)$ &
\end{tabular}


\subsection{Timing Functions}

%Timing functions take a certain number of continuous streams and return a continuous or event stream. The semantics for the timing functions are defined in the following.

The function $\mathtt{delay}$ shifts a stream by a specific amount of time.
We define the function for different signatures and any value domain $D$:
\begin{align*}
  \mathtt{delay}&: 𝓢_D × 𝕋 × D → 𝓢_D 
    & \mathtt{delay}(σ,d,v)(t) &:= \begin{cases} 
         σ(t-d) & \text{if } t-d≥0\\
         v      & \text{otherwise}
       \end{cases}\\
  \mathtt{delay}&: 𝓢_D × 𝕋_{≤0} → 𝓢_D 
    & \mathtt{delay}(σ,d)(t) &:= σ(t-d) \\
  \mathtt{delay}&: 𝓔_D × 𝕋 → 𝓔_D 
      & \mathtt{delay}(η,d)(t) &:= \begin{cases} 
           σ(t-d) & \text{if } t-d≥0\\
           ⊥      & \text{otherwise}
         \end{cases}\\
\end{align*}
The function $\mathtt{timestamp}$ provides the time stamp of an event stream element-wise:
\begin{align*}
  \mathtt{timestamp}&: 𝓔_D → 𝓔_𝕋 
    & \mathtt{timestamp}(η)(t) &:= \begin{cases}
        t & \text{if } t∈E(η)\\
        ⊥ & \text{otherwise}
      \end{cases}
\end{align*}

The function $\mathtt{within}$ serves for checking whether an event occurs within a given (relative) time bound. 
Further functions $\mathtt{inPast}$ and $\mathtt{inFuture}$ can be derived from $within$:
\begin{align*}
  \mathtt{within}&: 𝕋 × 𝕋 × 𝓔_D → 𝓢_𝔹 
    & \mathtt{within}(d_1,d_2,η)(t) &:= \begin{cases}
        \mathtt{true} & \text{if } E(η)∩[t+d_1,t+d_2]≠∅\\        
        \mathtt{false} & \text{otherwise}
      \end{cases}\\
  \mathtt{inPast}&: 𝕋_{≥0} × 𝓔_D → 𝓢_𝔹 
    & \mathtt{inPast}(d,η)(t) &:= within(-d,0,η)(t)\\
  \mathtt{inFuture}&: 𝕋_{≥0} × 𝓔_D → 𝓢_𝔹 
    & \mathtt{inFuture}(d,η)(t) &:= within(0,d,η)(t)
\end{align*}

\todo[inline,nolist]{TODO

The function $\mathtt{synchronise}$ matches events from two streams within a given time range.

\begin{align*}
  \mathtt{synchronise}&: 𝓔_D × 𝓔_D × 𝕋 → 
\end{align*}
}

\subsection{Aggregations}

For any domain $D$ with linear ordering and addition, respectively, e.g., $ℕ,ℤ,ℝ,ℚ$:
 
\begin{align*}
  \mathtt{maximum}&: 𝓔_D × D → 𝓢_D
    & \mathtt{maximum}(η,d)(t) &:= \max (｛d｝∪\{η(t') \mid t'∈E(η), t'≤t\})\\
  \mathtt{maximum}&: 𝓢_D → 𝓢_D
    & \mathtt{maximum}(σ)(t) &:= \max \{η(t') \mid t'∈𝕋, t'≤t\} \\
  \mathtt{minimum}&: 𝓔_D × D → 𝓢_D
    & \mathtt{minimum}(η,d)(t) &:= \min (｛d｝∪\{η(t') \mid t'∈E(η), t'≤t\})\\
  \mathtt{minimum}&: 𝓢_D → 𝓢_D
    & \mathtt{minimum}(σ)(t) &:= \min \{η(t') \mid t'∈𝕋, t'≤t\}\\
  \mathtt{sum}&: 𝓔_D → 𝓢_D
    & \mathtt{sum}(η)(t) &:= ∑_{t'∈E(η)｜t'≤t } η(t')\\  
\end{align*}

Generic functions $eventCount$ providing the number of occurred events and $mrv$ providing the most recent value of an event stream.

\begin{align*}
  \mathtt{eventCount}&: 𝓔_D → 𝓢_D
    & \mathtt{eventCount}(η)(t) &:= |{t'∈E(η)｜t'≤t } \\
  \mathtt{mrv}&: 𝓔_D × D → 𝓢_D
    & \mathtt{mrv}(η,d)(t) &:= \begin{cases}
         η(\max E(η)∩[0,t]) & \text{if } E(η)∩[0,t]≠∅ \\
         d & \text{otherwise}
       \end{cases}
\end{align*}

\subsection{Selectors/Filters/Conditionals/Combinators}

\begin{align*}
  \mathtt{ifThen}&: 𝓔_{D_1} × 𝓢_{D_2} → 𝓔_{D_2}
      & \mathtt{ifThen}(η,σ)(t) &:= \begin{cases}
           σ(t) & \text{if } t∈E(η)\\
           ⊥ & \text{otherwise}
         \end{cases}\\
  \mathtt{ifThenElse}&: 𝓢_𝔹 × 𝓢_D × 𝓢_D → 𝓢_D
      & \mathtt{ifThenElse}(σ_1,σ_2,σ_3)(t) &:= \begin{cases}
           σ_2(t) & \text{if } σ_1(t) = \texttt{true}\\
           σ_3(t) & \text{otherwise}
         \end{cases}\\
  \mathtt{merge}&: 𝓔_D × 𝓔_D → 𝓔_D
      & \mathtt{merge}(η_1,η_2)(t) &:= \begin{cases}
           η_1(t) & \text{if } t∈E(η_1)\\
           η_2(t) & \text{if } t∈E(η_2)∖E(η_1)\\
           ⊥ & \text{otherwise}
         \end{cases}
\end{align*}
Note that \texttt{ifThen} is a restricted form of an on-comprehension.

\subsection{Monitors}

The monitor function can be used to enable the usage of temporal logics within \tessla. 
A monitor is defined by a temporal logic formula and returns an output value that depends on the evaluation status of the given formula at the current point in time.
We assume that the temporal logic is defined over propositional variables from a fixed and finite set $AP=\{p_1,…,p_n\}$, e.g.\ like LTL.
Further, the semantics is defined on finites words over the alphabet $Σ=2^{AP}$ and admits truth values from some domain $𝕍$ (e.g., $𝔹$).
We then let, for arbitrary $D$,
\[
  \texttt{monitor}: TL × (𝓢_𝔹)^n × 𝓔_D → 𝓔_𝕍
\]
with 
\[
  \texttt{monitor}(φ, σ_1,…,σ_n,η)(t) := \begin{cases}
    ⟦w_t⊧φ⟧ & \text{if } t∈E(η) \\
    ⊥ & \text{otherwise}
   \end{cases}
\]
where $w_t=a_1…a_{|E(η)|}$ with $a_i=\{p_k∈AP \mid σ_k(t_i)=\texttt{true}\}$ for $\{t_1<t_2<…<t_{|E(η)|}\} = E(η)$.
