\section{Semantics}

The formal semantics of a \tessla specification is a function mapping a set of input streams to a set of output streams.

The set of output streams consists of all streams that are explicitly defined in the specification.
The set of input streams is defined implicitly by the set of names (and their type) denoting a stream that occurs freely in the specification, i.e., without definition.

That way, the semantics of the specification is build from (and depends on) the semantics of the functions used in the specification.
In the following we describe a set of convenient functions that could be considered as a „standard library“.

\subsection{Lifted Functions}

A function $f: D_1 × … × D_n → D_{n+1}$ on basic types can easily be lifted to a function $\hat{f}: 𝓢_{D_1} × … × 𝓢_{D_n} → 𝓢_{D_{n+1}}$ on signals with $\hat{f}(σ_1,…,σ_n)(t) = f(σ_1(t),…,σ_n(t))$ for all $t∈𝕋$.
This is possible since signals provide a value at every time point. 

We list some important lifted functions for arithmetics and boolean operations. 
They are defined as expected in terms of their scalar counterparts as above.

\begin{tabular}{lll}
  Function name, signature & Semantics & Remark\\
  \hline
  $\textttbf{add}: 𝓢_D × 𝓢_D → 𝓢_D$ & $\texttt{add}(σ_1,σ_2)(t) := σ_1(t) + σ_2(t)$ & $D∈\{ℕ,ℤ,ℝ\}$\\
  $\texttt{sub}: 𝓢_D × 𝓢_D → 𝓢_D$ & $\texttt{sub}(σ_1,σ_2)(t) := σ_1(t) - σ_2(t)$ & $D∈\{ℤ,ℝ\}$\\
  $\textttbf{mul}: 𝓢_D × 𝓢_D → 𝓢_D$ & $\texttt{mul}(σ_1,σ_2)(t) := σ_1(t) · σ_2(t)$ & $D∈\{ℕ,ℤ,ℝ\}$\\
  $\textttbf{div}: 𝓢_D × 𝓢_{D'} → 𝓢_D$ & $\texttt{div}(σ_1,σ_2)(t) := \frac{σ_1(t)}{σ_2(t)}$ & $D∈\{ℕ,ℤ,ℝ\}, D'=D∖｛0｝$\\
  $\textttbf{ge}: 𝓢_D × 𝓢_D → 𝓢_𝔹$ & $\texttt{ge}(σ_1,σ_2)(t) := σ_1(t) > σ_2(t)$ & $D∈\{ℕ,ℤ,ℝ\}$\\
  $\texttt{geq}: 𝓢_D × 𝓢_D → 𝓢_𝔹$ & $\texttt{geq}(σ_1,σ_2)(t) := σ_1(t) ≥ σ_2(t)$ & $D∈\{ℕ,ℤ,ℝ\}$\\
  $\texttt{leq}: 𝓢_D × 𝓢_D → 𝓢_𝔹$ & $\texttt{leq}(σ_1,σ_2)(t) := σ_1(t) ≤ σ_2(t)$ & $D∈\{ℕ,ℤ,ℝ\}$\\
  $\texttt{eq}: 𝓢_D × 𝓢_D → 𝓢_𝔹$ & $\texttt{eq}(σ_1,σ_2)(t) := σ_1(t) = σ_2(t)$ & any $D$ with equality\\
  $\textttbf{max}: 𝓢_D × 𝓢_D → 𝓢_D$ & $\texttt{max}(σ_1,σ_2)(t) := \max \{σ_1(t), σ_2(t)\}$ & $D∈\{ℕ,ℤ,ℝ\}$\\
  $\texttt{min}: 𝓢_D × 𝓢_D → 𝓢_D$ & $\texttt{min}(σ_1,σ_2)(t) := \min \{σ_1(t), σ_2(t)\}$ & $D∈\{ℕ,ℤ,ℝ\}$\\
  $\texttt{abs}: 𝓢_D → 𝓢_D$ & $\texttt{abs}(σ)(t) := |σ(t)|$ & $D∈\{ℕ,ℤ,ℝ\}$\\
  $\texttt{abs}: 𝓔_D → 𝓔_D$ & $\texttt{abs}(η)(t) := \begin{cases} |η(t)| & \text{if } t∈E(η) \\ ⊥&\text{otherwise} \end{cases}$&\\
  $\textttbf{and}: 𝓢_𝔹 × 𝓢_𝔹 → 𝓢_𝔹$ & $\texttt{and}(σ_1,σ_2)(t) := σ_1(t) ∧ σ_2(t)$ & \\
  $\texttt{or}: 𝓢_𝔹 × 𝓢_𝔹 → 𝓢_𝔹$ & $\texttt{or}(σ_1,σ_2)(t) := σ_1(t) ∨ σ_2(t)$ & \\
  $\texttt{implies}: 𝓢_𝔹 × 𝓢_𝔹 → 𝓢_𝔹$ & $\texttt{implies}(σ_1,σ_2)(t) := σ_1(t) ⇒ σ_2(t)$ & \\
  $\textttbf{not}: 𝓢_𝔹 → 𝓢_𝔹$ & $\texttt{not}(σ)(t) := ¬σ(t)$ &\\
  $\texttt{not}: 𝓔_𝔹 → 𝓔_𝔹$ & $\texttt{not}(η)(t) := \begin{cases} ¬η(t) & \text{if } t∈E(η) \\ ⊥&\text{otherwise} \end{cases}$&
\end{tabular}


\subsection{Timing Functions}

%Timing functions take a certain number of continuous streams and return a continuous or event stream. The semantics for the timing functions are defined in the following.

The function $\mathtt{delay}$ shifts a stream by a specific amount of time.
We define the function for different signatures and any value domain $D$:
\begin{align*}
  \mathtt{delay}&: 𝓢_D × 𝕋 × D → 𝓢_D 
    & \mathtt{delay}(σ,d,v)(t) &:= \begin{cases} 
         σ(t-d) & \text{if } t-d≥0\\
         v      & \text{otherwise}
       \end{cases}\\
  \mathtt{delay}&: 𝓢_D × 𝕋_{≤0} → 𝓢_D 
    & \mathtt{delay}(σ,d)(t) &:= σ(t-d) \\
  \textttbf{delay}&: 𝓔_D × 𝕋 → 𝓔_D 
      & \mathtt{delay}(η,d)(t) &:= \begin{cases} 
           σ(t-d) & \text{if } t-d≥0\\
           ⊥      & \text{otherwise}
         \end{cases}\\
\end{align*}
Discrete timporal shifts of event streams can be expressed by the functions
\begin{align*}
  \textttbf{delay}&: 𝓔_D → 𝓔_D\\
  \texttt{delay}&: 𝓔_D × ℕ_{>0} → 𝓔_D
\end{align*}
defined in terms of the sequence representation $s_η$ of event streams $η∈𝓔_D$. 
For $s_η = (t_0,η(t_0))(t_1,η(t_1))(t_2,η(t_2))…$ we define $\texttt{delay}(s_η) := (t_1,η(t_0))(t_2,η(t_1))…$. 
Notice that in case $|s_η|<2$ then $\texttt{delay}(s_η)=ε$ is empty.
A positive natural argument abbrevates iterated application, i.e., $\texttt{delay}(η,n) := \texttt{delay}^n(η)$.

The function $\mathtt{timestamp}$ provides the time stamp of an event stream element-wise:
\begin{align*}
  \textttbf{timestamp}&: 𝓔_D → 𝓔_𝕋 
    & \mathtt{timestamp}(η)(t) &:= \begin{cases}
        t & \text{if } t∈E(η)\\
        ⊥ & \text{otherwise}
      \end{cases}
\end{align*}

The function $\mathtt{within}$ serves for checking whether an event occurs within a given (relative) time bound. 
Further functions $\mathtt{inPast}$ and $\mathtt{inFuture}$ can be derived from $within$:
\begin{align*}
  \textttbf{within}&: 𝕋 × 𝕋 × 𝓔_D → 𝓢_𝔹 
    & \mathtt{within}(d_1,d_2,η)(t) &:= \begin{cases}
        \mathtt{true} & \text{if } E(η)∩[t+d_1,t+d_2]≠∅\\        
        \mathtt{false} & \text{otherwise}
      \end{cases}\\
  \mathtt{inPast}&: 𝕋_{≥0} × 𝓔_D → 𝓢_𝔹 
    & \mathtt{inPast}(d,η)(t) &:= \mathtt{within}(-d,0,η)(t)\\
  \mathtt{inFuture}&: 𝕋_{≥0} × 𝓔_D → 𝓢_𝔹 
    & \mathtt{inFuture}(d,η)(t) &:= \mathtt{within}(0,d,η)(t)
\end{align*}

\subsection{Synchronisation}

We define a function $\mathtt{synchronise}$ that matches events from two streams within a given time range.
 \todo{add example or ref appendix}
Its formal signature is defined as
\[
  \textttbf{synchronise}: 𝓔_{D_1} × 𝓔_{D_2} × 𝕋 → 𝓔_{(D_1+D_2)+(D_1×D_2)}.
\]
Recall that $A+B:= (A×｛1｝)∪(B×｛2｝)$\footnote{In programming languages, structures $A+B$ are often represented by a type \texttt{Either<A,B>} with subtypes \texttt{Left<A>} and \texttt{Right<B>} and suitable operations to access the wrapped values of type A and B, respectively (e.g., \texttt{get()}).}.

Since the function takes the temporal relation between the events into account it is most convenient to define its semantics inductively based on the sequence representation.
For $d∈𝕋_{≥0}$ and sequences $u∈(𝕋_{≥0}×D_1)^∞$ and $v∈(𝕋_{≥0}×D_2)^∞$ we define the sequence $sync(u,v)$ inductively by 
\[
sync(u,v) = \begin{cases}
  ε & \text{if } u=v=ε \\
  ((a,1,1),t_1+d) · sync(u',v) & \text{if } u=(a,t_1) ·u' \text{ and } \\
                                   & v=ε \text{ or } v=(b,t_2)·v' \text{ with } t_2>t_1+d\\
  ((b,2,1),t_2+d) · sync(u,v') & \text{if } v=(b,t_2)·v' \text{ and } \\
                                   & u=ε \text{ or } u=(a,t_1)·u' \text{ with } t_1>t_2+d\\
  ((a,b,2),\max｛t_1,t_2｝) · f(u',v') & \text{if } u=(a,t_1)·u' \text{, } v=(b,t_2)·v' \text{ and } |t_1-t_2|≤d
\end{cases}
\]

Based on $sync(u,v)$ we define $\mathtt{synchronise}(η_1,η_2,d) := η_3$ where $η_3$ is the event stream defined by the sequence $s_{η_3} = sync(s_{η_1}, s_{η_2})$. 
As defined in Section~\ref{sec:streams}, the sequences $s_{η_1}$ and $s_{η_2}$ are the sequences representing $η_1$ and $η_2$, respectively.

For convenience we further define some lifted functions to access the structural information.
\begin{align*}
  \mathtt{getLeft}&: 𝓔_{D_1×D_2} → 𝓔_{D_1}
    & \mathtt{getLeft}(η)(t) &:= \begin{cases}
        v_1 & \text{if } t∈E(η) \text{ and } η(t) = (v_1,v_2)\\
        ⊥ & \text{otherwise}
      \end{cases}\\
%
  \mathtt{getRight}&: 𝓔_{D_1×D_2} → 𝓔_{D_2}
    & \mathtt{getRight}(η)(t) &:= \begin{cases}
        v_2 & \text{if } t∈E(η) \text{ and } η(t) = (v_1,v_2)\\
        ⊥ & \text{otherwise}
      \end{cases}\\
%      
  \mathtt{getLeft}&: 𝓔_{(D_1+D_2)} → 𝓔_{D_1}
    & \mathtt{getLeft}(η)(t) &:= \begin{cases}
        v_1 & \text{if } t∈E(η) \text{ and } η(t) = (v_1,1)\\
        ⊥ & \text{otherwise}
      \end{cases}\\
%
  \mathtt{getRight}&: 𝓔_{(D_1+D_2)} → 𝓔_{D_2}
    & \mathtt{getRight}(η)(t) &:= \begin{cases}
        v_2 & \text{if } t∈E(η) \text{ and } η(t) = (v_2,2)\\
        ⊥ & \text{otherwise}
      \end{cases}\\
%
  \mathtt{get}&: 𝓔_{D_1+D_2} → 𝓔_{D_1∪D_2}
    & \mathtt{get}(η)(t) &:= \begin{cases}
        v & \text{if } t∈E(η) \text{ and } η(t) = (v,i) \text{ for } i∈｛1,2｝\\
        ⊥ & \text{otherwise}
      \end{cases}\\
\end{align*}
%
We define a function that indicates whether an event could not be synchronised within the given time bound:
\begin{align*}
  \mathtt{timeout}&: 𝓔_{(D_1+D_2)+(D_1×D_2)} → 𝓔_{｛⊤｝}\\
   \mathtt{timeout}(η)(t) & := \begin{cases}
            ⊤ & \text{if } t∈E(η) \text{ and } η(t) = (v,i,1)∈(D_1+D_2)×｛1｝\\
            ⊥ & \text{otherwise}
          \end{cases}\\
\end{align*}
%
A “flat” synchronisation simply neglects the origin of a value and gives precedence to the values of the first argument.
\begin{align*}
  &\mathtt{flatSynchronise}: 𝓔_D × 𝓔_D × 𝕋 → 𝓔_D\\
  &\mathtt{flatSynchronise}(η_1,η,_2,d)(t) := get(get(\mathtt{synchronise}(η_1,η_2,d)))
\end{align*}
%
If necessary, we can keep the timeout information.
\begin{align*}
  &\mathtt{flatSynchronise}: 𝓔_D × 𝓔_D × 𝕋 → 𝓔_{D×𝔹} \\
  &\mathtt{flatSynchronise}(η_1,η,_2,d)(t) := \begin{cases}
        (v,\texttt{true}) & \texttt{if } \mathtt{synchronise}(η_1,η,2,d)(t) = (v,i,1) \texttt{ for } i∈｛1,2｝\\
        (v_1,\texttt{false}) & \texttt{if } \mathtt{synchronise}(η_1,η,2,d)(t) = (v_1,v_2,2) \\
        ⊥ & \texttt{otherwise}
        \end{cases}
\end{align*}

\subsection{Aggregations}

For any domain $D$ with linear ordering and addition, respectively, e.g., $ℕ,ℤ,ℝ,ℚ$:
 
\begin{align*}
  \mathtt{maximum}&: 𝓔_D × D → 𝓢_D
    & \mathtt{maximum}(η,d)(t) &:= \max (｛d｝∪\{η(t') \mid t'∈E(η), t'≤t\})\\
  \textttbf{maximum}&: 𝓢_D → 𝓢_D
    & \mathtt{maximum}(σ)(t) &:= \max \{η(t') \mid t'∈𝕋, t'≤t\} \\
  \mathtt{minimum}&: 𝓔_D × D → 𝓢_D
    & \mathtt{minimum}(η,d)(t) &:= \min (｛d｝∪\{η(t') \mid t'∈E(η), t'≤t\})\\
  \mathtt{minimum}&: 𝓢_D → 𝓢_D
    & \mathtt{minimum}(σ)(t) &:= \min \{η(t') \mid t'∈𝕋, t'≤t\}\\
  \textttbf{sum}&: 𝓔_D → 𝓢_D
    & \mathtt{sum}(η)(t) &:= ∑_{t'∈E(η)｜t'≤t } η(t')\\  
\end{align*}

Generic functions $eventCount$ providing the number of occurred events and $mrv$ providing the most recent value of an event stream.

\begin{align*}
  \textttbf{eventCount}&: 𝓔_D → 𝓢_D
    & \mathtt{eventCount}(η)(t) &:= |{t'∈E(η)｜t'≤t } \\
  \textttbf{mrv}&: 𝓔_D × D → 𝓢_D
    & \mathtt{mrv}(η,d)(t) &:= \begin{cases}
         η(\max E(η)∩[0,t]) & \text{if } E(η)∩[0,t]≠∅ \\
         d & \text{otherwise}
       \end{cases}
\end{align*}

We further define the simple moving average on streams of arithmetic type.
Let $\max_1(M) := ｛\max M｝$ and $\max_{n+1}(M) := ｛\max M｝ ∪ \max_n (M∖(\max M))$ denote the set of the $n$ largest elements of a linearly ordered set $M$. \todo{move to preliminaries} 
Then, we define the simple moving average $\mathtt{sma}: 𝓔_D × ℕ_{>0} → 𝓔_D$ as
\[
   \mathtt{sma}(η,n)(t) := \begin{cases}
      \frac{∑_{t'∈ \max_n ｛t''∈E(η)｜t''≤t  ｝} η(t')}{|\max_n ｛t'∈E(η)｜t'≤t ｝|} & \text{if } t∈E(η)\\
      ⊥ & \text{otherwise}
    \end{cases}
\]
Notice that for a fixed $n$ we have that 
\begin{lstlisting}[language=tessla,mathescape]
define std_mean_avg := sma(in1, $n$)
out std_mean_avg
\end{lstlisting}
is equivalent to
\begin{lstlisting}[language=tessla,mathescape]
define x$_1$ = in1
define x$_2$ = delay(x$_1$)
define x$_3$ = delay(x$_2$)
...
define x$_n$ = delay(x$(n-1)$)
define sum = add(x$_1$,add($...$add(x$_{n-1}$, x$_n$)$...$))
define std_mean_avg := on x$_n$ yield ifThenElse(sum>0, sum/$n$, 0)
out std_mean_avg
\end{lstlisting}

\subsection{Selectors/Filters/Conditionals/Combinators}

\begin{align*}
  \textttbf{changeOf}&: 𝓢_{D} → 𝓔_{｛⊤｝}
      & \mathtt{changeOf}(σ)(t) &:= \begin{cases}
           ⊤ & \text{if } t∈Δ(σ)\\
           ⊥ & \text{otherwise}
         \end{cases}\\
  \textttbf{ifThen}&: 𝓔_{D_1} × 𝓢_{D_2} → 𝓔_{D_2}
      & \mathtt{ifThen}(η,σ)(t) &:= \begin{cases}
           σ(t) & \text{if } t∈E(η)\\
           ⊥ & \text{otherwise}
         \end{cases}\\
  \mathtt{sample}&: 𝓢_{D_1} × 𝓔_{D_2} → 𝓔_{D_1}
      & \mathtt{sample}(σ,η) &:= \mathtt{ifThen}(η,σ)\\
  \textttbf{filter}&: 𝓔_D × 𝓢_𝔹 → 𝓔_D
      & \mathtt{filter}(η,σ)(t) &:= \begin{cases}
           η(t) & \text{if } t∈E(η) \\[-0.75ex]
                 & \text{and } σ(t) = \texttt{true}\\
           ⊥ & \text{otherwise}
         \end{cases}\\
  \mathtt{ifThenElse}&: 𝓢_𝔹 × 𝓢_D × 𝓢_D → 𝓢_D
      & \mathtt{ifThenElse}(σ_1,σ_2,σ_3)(t) &:= \begin{cases}
           σ_2(t) & \text{if } σ_1(t) = \texttt{true}\\
           σ_3(t) & \text{otherwise}
         \end{cases}\\
  \mathtt{merge}&: 𝓔_D × 𝓔_D → 𝓔_D
      & \mathtt{occurAny}(η_1,η_2)(t) &:= \begin{cases}
           η_1(t) & \text{if } t∈E(η_1)\\
           η_2(t) & \text{if } t∈E(η_2)∖E(η_1)\\
           ⊥ & \text{otherwise}
         \end{cases}\\
   \textttbf{occurAny}&: 𝓔_{D_1} × 𝓔_{D_2} → 𝓔_{｛⊤｝}
        & \mathtt{occurAny}(η_1,η_2)(t) &:= \begin{cases}
             ⊤ & \text{if } t∈E(η_1)∪E(η_2)\\
             ⊥ & \text{otherwise}
           \end{cases}\\
  \textttbf{occurAll}&: 𝓔_{D_1} × 𝓔_{D_2} → 𝓔_{｛⊤｝}
      & \mathtt{occurAll}(η_1,η_2)(t) &:= \begin{cases}
           ⊤ & \text{if } t∈E(η_1)∩E(η_2)\\
           ⊥ & \text{otherwise}
         \end{cases}
\end{align*}
Notice that \texttt{merge} gives precedence to the first argument and that \texttt{ifThen} is a restricted form of an on-comprehension.

\subsection{Monitors}

The monitor function can be used to enable the usage of temporal logics within \tessla. 
A monitor is defined by a temporal logic formula and returns an output value that depends on the evaluation status of the given formula at the current point in time.
We assume that the temporal logic is defined over propositional variables from a fixed and finite set $AP=\{p_1,…,p_n\}$, e.g.\ like LTL.
Further, the semantics is defined on finite words over the alphabet $Σ=2^{AP}$ and admits truth values from some domain $𝕍$ (e.g., $𝔹$).
We then let, for arbitrary $D$,
\[
%  \textttbf{monitor}: TL × (𝓢_𝔹)^n × 𝓔_D → 𝓔_𝕍
  \textttbf{monitor}: TL × (𝓢_𝔹∪𝓔_⊥)^n  → 𝓔_𝕍
\]
with 
\[
  \texttt{monitor}(φ, σ_1,…,σ_n,η)(t) := \begin{cases}
    ⟦w_t⊧φ⟧ & \text{if } t∈E(η) \\
    ⊥ & \text{otherwise}
   \end{cases}
\]
where $w_t=a_1…a_{m}$ with $a_i=\{p_k∈AP \mid σ_k(t_i)=\texttt{true}\}$ for $\{t_1<t_2<…<t_{|E(η)|}\} = E(η)$ and $t_m≤t<t_{m+1}$.

\idea[inline]{
For practical convenience we could introduce further notation such as where explicit inputs are optionals and instead of fixed propositions $p_1…p_n$ escaped \tessla expressions can be used. For example,

\texttt{monitor("always (p1 implies eventually not p2)", myFunction(in1, in2), in3)}

could be written as

\texttt{monitor "always ( \{myFunction(in1, in2)\}  implies eventually not \{in3\})"}.
}

\subsection{On-comprehension}

Let $η_1∈𝓔_{D_1},…,η_n∈𝓔_{D_n}$ be event streams, $σ_{cnd}∈𝓢_𝔹$ a Boolean signal and $σ_{val}∈𝓢_D$ a signal of some type $D$.
We define the semantics of on-comprehensions as follows.

\begin{align*}
      ⟦\textttbf{on }η_1,…,η_n  \textttbf{ if } σ_{cnd} \textttbf{ yield } σ_{val}⟧(t) &:= \begin{cases}
             σ_{val}(t) & \text{if } t∈⋂_{i=1}^n E(η_i)  \text{ and } σ_{cnd}(t)=\mathtt{true}\\
             ⊥ & \text{otherwise}
           \end{cases}\\
\end{align*}
Omitting the \texttt{yield} part amounts to implicitly take $σ_{val} = σ_⊤$ where $σ_⊤: 𝕋_{≥0} → ｛⊤｝$ is the (unique) signal of type \texttt{Unit}.
Omitting the conditional (\texttt{if}) part amount to implicitly take $σ_{cnd}=σ_{\mathtt{true}}$ where $σ_\mathtt{true}: 𝕋_{≥0} → ｛\texttt{true}｝$ is the Boolean signal that is always true.
