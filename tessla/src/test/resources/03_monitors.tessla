in MessageTimeStampNode: Events<Int>
in instructionReconstructionMessage.InstructionReconstructionID: Events<Int>
in regChangeMessage.RegChangeMessageValue: Events<Int>
in regChangeMessage.RegChangeMessageID: Events<Int>

define input_vector_timestamps := MessageTimeStampNode
define input_vector_ir_ids := instructionReconstructionMessage.InstructionReconstructionID
define input_vector_RegChangeMessageValue := regChangeMessage.RegChangeMessageValue
define input_vector_RegChangeMessageID := regChangeMessage.RegChangeMessageID

--
-- Macros
--
define prop(e1,e2) := mrv(merge(ifThen(e1, constantSignal(true)), ifThen(e2, constantSignal(false))), false)
define exec(x) := filter(on(input_vector_ir_ids), eq(mrv(input_vector_ir_ids, 0), constantSignal(x)))

--
-- Input
--
--define readPointerAddr := variable_values("main.c:read_idx")
define readPointerChanged := exec(1)
--define stopConsumer := function_calls("main.c:stopConsumers")
define stopConsumer := exec(2)
--define startConsumer := function_calls("main.c:startConsumers")
define startConsumer := exec(3)


--
-- Spec
--
--define readPointerChanged := changeOf(readPointerAddr)
define clk := occursAny(occursAny(stopConsumer, readPointerChanged), startConsumer)
define stop := prop(stopConsumer, clk)
define start := prop(startConsumer, clk)
define change := prop(readPointerChanged, clk)

define monitor_output := monitor("
  always(p1 implies (not(p2) until p3))",
  p1 := stop,
  p2 := change,
  p3 := start,
  clock := clk
)

out monitor_output
