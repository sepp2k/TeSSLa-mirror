# def fac(a: Int): Int = if a <= 1 then 1 else fac(a - 1) * a
# def call(f: (Int) => Int, a: Int): Int = f(a)
# out slift1(x, (x: Int) => call(fac, x))

# def square(x: Int): Int = {
#     def prod(a: Int): Int = if a < 1 then x else prod(a - 1) * x
#     prod(x)
# }
# out slift1(x, square)

# Hier brauchen wir eine Box
# def mult_(x: Int): (Int) => Int = (y: Int) => x * y

# Hier muss man prod umformen, damit das sich rekursiv aufrufen kann
# def mult(x: Int): (Int) => Int = {
#     def prod(a: Int): Int = if a < 1 then x else prod(a - 1) * x
#     prod
# }
# out slift2(x, x, (x: Int, y: Int) => mult(x)(y))

# Generics can't be function type
# def ite(cond: strict Bool, thenCase: lazy (Int) => Int, elseCase: lazy (Int) => Int): (Int) => Int = extern("ite")
# def foo(x: Int): (Int) => Int = {
#     ite(x < 1, (y: Int) => y, (y: Int) => foo(y - 1)(x))
#     # if x < 1 then (y: Int) => y else (y: Int) => foo(y - 1)(x)
# }
# out slift1(x, foo(5))