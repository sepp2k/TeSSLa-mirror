/*
 * Copyright (c) 2020 Institute of Software Engineering and Programming Languages,
 * University of LÃ¼beck, Germany
 *
 * Modified MIT license:
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this binary (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software and the code which is
 * generated by the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

package de.uni_luebeck.isp.tessla.interpreter

import java.io.File

import de.uni_luebeck.isp.tessla.core.Errors.InternalError
import de.uni_luebeck.isp.tessla.core.{Location, Tessla}
import org.eclipse.tracecompass.ctf.core.trace.{CTFTrace, CTFTraceReader}

import scala.io.Source

/**
 * Factory for [[Interpreter.Trace]]s.
 */

object Trace {
  type Identifier = Tessla.Identifier
  val Identifier = Tessla.Identifier

  /** Representation of a single event in a trace.
   *
    * @param loc the location information of this event, used for error messages
   * @param timeStamp the timestamp of the event
   * @param streamOpt the identifier of the stream this event is associated to. If not existing, the stream is
   *                  considered to be a raw stream.
   * @param value the data value of the event
   */
  case class Event(loc: Location, timeStamp: TimeStamp, streamOpt: Option[Identifier], value: Any) {
    override def toString: String = streamOpt match {
      case Some(stream) => s"$timeStamp: ${stream.name} = $value"
      case None         => value.toString
    }

    def stream: Identifier = streamOpt match {
      case Some(stream) => stream
      case None         => throw InternalError("Requested name of raw stream")
    }
  }

  case class TimeStamp(loc: Location, time: StreamEngine.Time) {
    override def toString: String = time.toString
  }

  def fromCtfFile(ctfFile: File, abortAt: Option[BigInt]): Interpreter.Trace = {
    new CtfEventIterator(new CTFTraceReader(new CTFTrace(ctfFile)), abortAt)
  }

  def fromLineIterator(
    lineIterator: Iterator[String],
    fileName: String,
    abortAt: Option[StreamEngine.Time] = None
  ): Interpreter.Trace = {
    val rawTrace = TraceParser.parseTrace(lineIterator, fileName)
    new EventIterator(rawTrace, abortAt)
  }

  def fromSource(
    traceSource: Source,
    fileName: String,
    abortAt: Option[StreamEngine.Time] = None
  ): Interpreter.Trace = {
    fromLineIterator(traceSource.getLines(), fileName, abortAt)
  }

  def fromFile(file: File, abortAt: Option[StreamEngine.Time] = None): Interpreter.Trace =
    fromSource(Source.fromFile(file), file.getName, abortAt)

  def fromString(string: String, fileName: String, abortAt: Option[StreamEngine.Time] = None): Interpreter.Trace =
    fromSource(Source.fromString(string), fileName, abortAt)

  def fromCsvLineIterator(
    lineIterator: Iterator[String],
    fileName: String,
    abortAt: Option[StreamEngine.Time] = None
  ): Interpreter.Trace = {
    val rawTrace = TraceParser.parseCsvTrace(lineIterator, fileName)
    new EventIterator(rawTrace, abortAt)
  }

  def fromCsvSource(
    traceSource: Source,
    fileName: String,
    abortAt: Option[StreamEngine.Time] = None
  ): Interpreter.Trace = {
    fromCsvLineIterator(traceSource.getLines(), fileName, abortAt)
  }

  def fromCsvFile(file: File, abortAt: Option[StreamEngine.Time] = None): Interpreter.Trace =
    fromCsvSource(Source.fromFile(file), file.getName, abortAt)

  def fromCsvString(string: String, fileName: String, abortAt: Option[StreamEngine.Time] = None): Interpreter.Trace =
    fromCsvSource(Source.fromString(string), fileName, abortAt)
}
