/*
 * Copyright (c) 2020 Institute of Software Engineering and Programming Languages,
 * University of LÃ¼beck, Germany
 *
 * Modified MIT license:
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this binary (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software and the code which is
 * generated by the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

package de.uni_luebeck.isp.tessla.core

import scala.collection.mutable

/**
 * A flat representation of TeSSLa code.
 *
  * All the definitions are grouped in an instance of [[Definitions]], which is potentially composed of more instances,
 * modelling the scopes of definitions.
 *
  * Entries to definitions are either [[TypeEntry]] for type definitions, or [[VariableEntry]] for all other kinds of
 * definitions.
 *
  * @see [[Flattener]]
 */

abstract class FlatTessla extends HasUniqueIdentifiers {
  case class Specification(
    annotations: Seq[Annotation],
    globalDefs: Definitions,
    outStreams: Seq[OutStream],
    outAll: Option[OutAll],
    globalNames: Map[String, Identifier]
  ) {
    override def toString = {
      val outAllString = outAll.map(_.toString).getOrElse("")
      s"${annotations.mkString("\n")}\n$globalDefs\n${outStreams.mkString("\n")}$outAllString"
    }

    def hasOutAll = outAll.isDefined
  }

  type TypeAnnotation
  def typeAnnotationToString(typeAnnotation: TypeAnnotation): String

  case class Annotation(
    name: String,
    arguments: Map[String, Tessla.ConstantExpression],
    loc: Location
  )

  case class VariableEntry(
    id: Identifier,
    expression: Expression,
    typeInfo: TypeAnnotation,
    annotations: Seq[Annotation],
    loc: Location
  )
  case class TypeEntry(
    id: Identifier,
    arity: Int,
    typeConstructor: Seq[Type] => Type,
    loc: Location
  )

  class Definitions(val parent: Option[Definitions]) {
    val variables = mutable.Map[Identifier, VariableEntry]()
    val types = mutable.Map[Identifier, TypeEntry]()

    def addVariable(entry: VariableEntry): Unit = {
      variables(entry.id) = entry
    }

    def addType(entry: TypeEntry): Unit = {
      types(entry.id) = entry
    }

    def resolveVariable(id: Identifier): Option[VariableEntry] = {
      variables.get(id).orElse(parent.flatMap(_.resolveVariable(id)))
    }

    def resolveType(id: Identifier): Option[TypeEntry] = {
      types.get(id).orElse(parent.flatMap(_.resolveType(id)))
    }

    override def toString = {
      s"-- Definitions $hashCode\n" + variables
        .map {
          case (id, entry) =>
            val typeAnnotation = typeAnnotationToString(entry.typeInfo)
            s"def $id$typeAnnotation = ${entry.expression}"
        }
        .mkString("\n") + types
        .map {
          case (id, entry) =>
            s"type $id[${entry.arity}] = ${entry.id}"
        }
        .mkString("\n") + parent
        .map(p => s"\n-- Parent = Definitions ${p.hashCode}\n")
        .getOrElse("") ++ "-- /Definitions"
    }
  }

  sealed abstract class Expression {
    def loc: Location
  }

  case class Macro(
    typeParameters: Seq[Identifier],
    parameters: Seq[(Option[TesslaAST.RuntimeEvaluation], Parameter)],
    body: Definitions,
    returnType: TypeAnnotation,
    headerLoc: Location,
    result: IdLoc,
    loc: Location,
    isLiftable: Boolean
  ) extends Expression {
    override def toString = {
      val liftable = if (isLiftable) "liftable " else ""
      s"$liftable[${typeParameters.mkString(", ")}](${parameters.mkString(", ")}) => {\n$body\n$result\n}"
    }
  }

  case class Extern(
    name: String,
    typeParameters: Seq[Identifier],
    parameters: Seq[(Option[TesslaAST.RuntimeEvaluation], Parameter)],
    referenceImplementation: Option[Identifier],
    loc: Location
  ) extends Expression {
    override def toString = s"extern($name)"
  }

  case class InputStream(name: String, streamType: Type, typeLoc: Location, loc: Location) extends Expression {
    override def toString = s"in $name: $streamType"
  }

  case class Parameter(param: Tessla.Parameter, parameterType: Type, id: Identifier) extends Expression {
    def name = param.id.name

    def nameWithLoc = param.id

    def idLoc: IdLoc = IdLoc(id, loc)

    override def loc = param.loc

    override def toString = s"param $name: $parameterType"
  }

  case class Variable(id: Identifier, loc: Location) extends Expression {
    override def toString = id.toString
  }

  case class MacroCall(
    macroID: Identifier,
    macroLoc: Location,
    typeArgs: Seq[Type],
    args: Seq[Argument],
    loc: Location
  ) extends Expression {
    override def toString = args.mkString(s"$macroID(", ", ", ")")
  }

  case class IdLoc(id: Identifier, loc: Location)

  case class ObjectLiteral(members: Map[String, IdLoc], loc: Location) extends Expression

  case class MemberAccess(receiver: IdLoc, member: String, memberLoc: Location, loc: Location) extends Expression

  case class Literal(value: LiteralValue, loc: Location) extends Expression {
    override def toString = value.toString
  }

  type LiteralValue = Tessla.LiteralValue

  sealed abstract class Type {
    def isValueType: Boolean
    def isStreamType = false
    def isLiftableFunctionType = false
  }

  case class BuiltInType(name: String, typeArgs: Seq[Type]) extends Type {
    //TODO: Make this less stupid
    override def isValueType = name != "Events"

    override def isStreamType = name == "Events"

    override def toString = {
      if (typeArgs.isEmpty) name
      else typeArgs.mkString(s"$name[", ", ", "]")
    }
  }

  case class ObjectType(memberTypes: Map[String, Type]) extends Type {
    override def isValueType = memberTypes.values.forall(_.isValueType)

    override def toString = {
      val tupleKeys = (1 to memberTypes.keys.size).map(i => s"_$i")
      if (memberTypes.keys.toSet == tupleKeys.toSet) {
        memberTypes.toList.sortBy(_._1).map(_._2).mkString("(", ", ", ")")
      } else {
        val members = memberTypes.map { case (name, t) => s"$name: $t" }.toSeq
        members.mkString("{", ", ", "}")
      }
    }
  }

  case class FunctionType(
    typeParameters: Seq[Identifier],
    parameterTypes: Seq[(Option[TesslaAST.RuntimeEvaluation], Type)],
    returnType: Type,
    isLiftable: Boolean
  ) extends Type {
    override def isValueType = false

    override def isLiftableFunctionType = isLiftable

    override def toString = {
      val liftableString = if (isLiftable) "liftable " else ""
      val typeParamString =
        typeParameters.map(id => id.nameOpt.getOrElse(id.toString)).mkString(", ")
      def paramString = parameterTypes
        .map {
          case (e, t) => s"${e.map(_.toString + " ").getOrElse("")}$t"
        }
        .mkString(", ")
      s"$liftableString[$typeParamString]($paramString) => $returnType"
    }
  }

  case class TypeParameter(id: Identifier, loc: Location) extends Type {
    // TODO: Handle this properly via constraints instead of restricting all type variables to only stand for
    //       value types.
    //       This will entail removing the isValueType method and instead handling this in the type checker
    //       where the type environment is available
    override def isValueType = true

    override def toString = id.nameOpt.getOrElse(id.toString)

    override def equals(other: Any) = other match {
      case tvar: TypeParameter => id == tvar.id
      case _                   => false
    }

    override def hashCode() = id.hashCode()
  }

  case class OutStream(id: Identifier, name: String, annotations: Seq[Annotation], loc: Location) {
    override def toString = s"out $id as $name"
  }

  case class OutAll(annotations: Seq[Annotation], loc: Location) {
    override def toString = "out *"
  }

  sealed abstract class Argument {
    def loc: Location
    def id: Identifier
  }

  case class PositionalArgument(id: Identifier, loc: Location) extends Argument {
    override def toString = id.toString
  }

  case class NamedArgument(name: String, idLoc: IdLoc, loc: Location) extends Argument {
    def id = idLoc.id

    override def toString = s"$name = $id"
  }
}

object FlatTessla extends FlatTessla {
  type TypeAnnotation = Option[Type]

  override def typeAnnotationToString(typeAnnotation: TypeAnnotation) = typeAnnotation match {
    case None    => ""
    case Some(t) => s" : $t"
  }

}
