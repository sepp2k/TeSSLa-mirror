/*
 * Copyright (c) 2020 Institute of Software Engineering and Programming Languages,
 * University of LÃ¼beck, Germany
 *
 * Modified MIT license:
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this binary (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software and the code which is
 * generated by the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

package de.uni_luebeck.isp.tessla.core.util

import cats._

/**
 * Defers a computation until `get` is invoked.
 * Supports the notion of a call stack.
 * Used to keep track of the stack when walking an AST recursively using lazy computation.
 */
class LazyWithStack[Frame]() {

  type Stack = List[Frame]

  object Lazy {
    def apply[A](a: => A): StackLazy[A] = new StackLazyImpl(_ => a)
  }

  object StackLazy {
    def apply[A](a: Stack => A): StackLazy[A] = new StackLazyImpl(a)

    implicit def monadInstance: CommutativeMonad[StackLazy] = new CommutativeMonad[StackLazy] {
      override def pure[A](x: A) = StackLazy(_ => x)

      override def map[A, B](fa: StackLazy[A])(f: A => B) = StackLazy { stack =>
        f(fa.get(stack))
      }

      override def flatMap[A, B](fa: StackLazy[A])(f: A => StackLazy[B]) =
        StackLazy[B](stack => f(fa.get(stack)).get(stack))

      override def tailRecM[A, B](a: A)(f: A => StackLazy[Either[A, B]]): StackLazy[B] =
        flatMap(f(a)) {
          case Right(b)    => pure(b)
          case Left(nextA) => tailRecM(nextA)(f)
        }
    }

  }

  sealed trait StackLazy[+A] {
    self =>
    def get(stack: Stack): A

    def push(f: Frame): StackLazy[A] = new StackLazy[A] {
      override def get(stack: Stack): A = self.get(f :: stack)
    }
  }

  private class StackLazyImpl[+A](a: Stack => A) extends StackLazy[A] {
    self =>
    override def toString = s"Lazy($a)"

    private var computing = false

    private[this] var result: Option[A] = None

    override def get(stack: Stack): A = {
      result match {
        case Some(r) => r
        case None =>
          val rec = computing
          computing = true
          try {
            val r = call(stack, rec)(a)
            result = Some(r)
            r
          } finally {
            computing = false
          }
      }
    }
  }

  protected def call[A](stack: Stack, rec: Boolean)(a: Stack => A) = a(stack)

}
