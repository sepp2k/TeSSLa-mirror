/*
 * Copyright (c) 2020 Institute of Software Engineering and Programming Languages,
 * University of LÃ¼beck, Germany
 *
 * Modified MIT license:
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this binary (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software and the code which is
 * generated by the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

package de.uni_luebeck.isp.tessla.core

import de.uni_luebeck.isp.tessla.core.Errors.ParserError

object Tessla {

  case class Specification(annotations: Seq[Annotation], statements: Seq[Statement]) {
    override def toString =
      s"${annotations.mkString("\n")}\n${statements.mkString("\n")}"
  }

  case class Identifier(name: String, loc: Location) extends Location.HasLoc {
    override def toString = name
  }

  sealed abstract class Statement extends Location.HasLoc {
    def loc: Location
  }

  case class Definition(
    id: Identifier,
    typeParameters: Seq[Identifier],
    parameters: Seq[(Option[TesslaAST.RuntimeEvaluation], Parameter)],
    returnType: Option[Type],
    parens: Boolean,
    headerLoc: Location,
    body: Body,
    loc: Location,
    isLiftable: Boolean
  ) extends Statement {
    override def toString = toString(objectNotation = false)

    def toString(objectNotation: Boolean) = {
      val liftable = if (isLiftable) "liftable " else ""
      val typeParameterList =
        if (typeParameters.isEmpty) ""
        else typeParameters.mkString("[", ", ", "]")
      val parameterList =
        if (parameters.isEmpty) ""
        else parameters.mkString("(", ", ", ")")
      val defString = if (objectNotation) "" else "def "
      val assign = if (objectNotation) "=" else ":="
      s"$liftable$defString$id$typeParameterList$parameterList $assign $body"
    }
  }

  case class Annotation(id: Identifier, arguments: Seq[Argument[Expression]], loc: Location) {
    def name: String = id.name

    override def toString: String = s"@$id(${arguments.mkString(", ")})"
  }

  sealed abstract class Body extends Location.HasLoc {
    def loc: Location
  }

  case class ExpressionBody(exp: Expression) extends Body {
    override def toString = exp.toString

    override def loc = exp.loc
  }

  case class Extern(id: Identifier, referenceImplementation: Option[Expression]) extends Body {
    override def toString = s"extern($id)"

    override def loc = id.loc
  }

  case class Module(id: Identifier, contents: Seq[Statement], loc: Location) extends Statement {
    override def toString = contents.mkString(s"module $id {\n", "\n", "\n}")

    def name: String = id.name
  }

  case class Import(path: List[Identifier], loc: Location) extends Statement {
    override def toString = s"import ${path.mkString(".")}"
  }

  case class AnnotationDefinition(
    id: Identifier,
    parameters: Seq[Parameter],
    global: Boolean,
    loc: Location
  ) extends Statement

  case class TypeDefinition(
    id: Identifier,
    typeParameters: Seq[Identifier],
    body: TypeBody,
    loc: Location
  ) extends Statement {
    override def toString = {
      val typeParameterList =
        if (typeParameters.isEmpty) ""
        else typeParameters.mkString("[", ", ", "]")
      s"type $id$typeParameterList = $body"
    }
  }

  sealed abstract class TypeBody

  case class TypeAlias(typ: Type) extends TypeBody {
    override def toString = typ.toString
  }

  case class ExternType(id: Identifier) extends TypeBody {
    override def toString = s"extern($id)"
  }

  case class In(id: Identifier, streamType: Type, annotations: Seq[Annotation], loc: Location) extends Statement {
    override def toString = s"in $id: $streamType"
  }

  case class Out(expr: Expression, id: Identifier, annotations: Seq[Annotation], loc: Location) extends Statement {
    def name = id.name

    override def toString = s"out $expr as $name"
  }

  case class OutAll(annotations: Seq[Annotation], loc: Location) extends Statement {
    override def toString = "out *"
  }

  def getId(statement: Tessla.Statement): Option[Tessla.Identifier] = statement match {
    case definition: Tessla.Definition => Some(definition.id)
    case in: Tessla.In                 => Some(in.id)
    case module: Tessla.Module         => Some(module.id)
    case _                             => None
  }

  case class Parameter(id: Identifier, parameterType: Option[Type]) extends Location.HasLoc {
    override def toString = parameterType match {
      case Some(t) => s"${id.name}: $t"
      case None    => id.name
    }

    def name: String = id.name

    def loc: Location = parameterType match {
      case Some(t) => id.loc.merge(t.loc)
      case None    => id.loc
    }
  }

  sealed abstract class Expression extends Location.HasLoc {
    def loc: Location

    def toString(inner: Boolean): String

    override def toString: String = toString(false)
  }

  case class Variable(id: Identifier) extends Expression {
    def loc = id.loc

    override def toString(inner: Boolean) = id.name
  }

  case class RootMemberAccess(member: Identifier, loc: Location) extends Expression {
    override def toString(inner: Boolean) = s"__root__.$member"
  }

  private val ID_PATTERN = "^[a-zA-Z0-9_]+$".r

  case class MacroCall(mac: Expression, typeArgs: Seq[Type], args: Seq[Argument[Expression]], loc: Location)
      extends Expression {
    override def toString(inner: Boolean) = {
      val typeArgList =
        if (typeArgs.isEmpty) ""
        else typeArgs.mkString("[", ", ", "]")

      var atomic = true
      val str = mac match {
        case Variable(id) =>
          (id.name, args) match {
            case (ID_PATTERN(), _) | (_, Seq()) => s"$mac$typeArgList(${args.mkString(", ")})"
            case ("if then", Seq(cond, thenCase)) =>
              atomic = false
              s"if $cond then $thenCase"
            case (name, Seq(PositionalArgument(arg))) => s"$name${arg.toString(inner = true)}"
            case (name, Seq(PositionalArgument(lhs), PositionalArgument(rhs))) =>
              atomic = false
              s"${lhs.toString(inner = true)} $name ${rhs.toString(inner = true)}"
            case (name, _) => s"$name$typeArgList(${args.mkString(", ")})"
          }
        case _ => s"${mac.toString(inner = true)}$typeArgList(${args.mkString(", ")})"
      }
      if (inner && !atomic) s"($str)" else str
    }
  }

  case class Block(definitions: Seq[Definition], expression: Expression, loc: Location) extends Expression {
    override def toString(inner: Boolean) = s"{\n${definitions.mkString("\n")}\n$expression\n}"
  }

  case class ObjectLiteral(members: Map[Identifier, Expression], loc: Location) extends Expression {
    override def toString(inner: Boolean) = {
      members.mkString("${", ", ", "}")
    }
  }

  case class Lambda(
    parameters: Seq[(Option[TesslaAST.RuntimeEvaluation], Parameter)],
    headerLoc: Location,
    body: Expression,
    loc: Location
  ) extends Expression {
    override def toString(inner: Boolean) = {
      val str = s"fun (${parameters.mkString(", ")}) => $body"
      if (inner) s"($str)" else str
    }
  }

  case class MemberAccess(receiver: Expression, member: Identifier, loc: Location) extends Expression {
    override def toString(inner: Boolean) = s"${receiver.toString(inner = true)}.$member"
  }

  case class Literal(value: LiteralValue, loc: Location) extends Expression {
    override def toString(inner: Boolean) = value.toString
  }

  sealed abstract class LiteralValue {
    def value: Any

    override def toString = value.toString
  }

  case class IntLiteral(value: BigInt) extends LiteralValue

  case class TimeLiteral(value: BigInt, unit: TimeUnit) extends LiteralValue {
    override def toString = s"$value $unit"
  }

  object TimeLiteral {
    def fromString(str: String, loc: Location): TimeLiteral = {
      val re = raw"""([0-9]+)\s*([_\p{L}][_\p{L}\p{Digit}]*)""".r
      str match {
        case re(int, unit) => TimeLiteral(int.toInt, TimeUnit.fromString(unit, loc))
        case _             => throw ParserError(s"Unable to parse time literal $str", loc)
      }
    }
  }

  case class FloatLiteral(value: Double) extends LiteralValue

  case class StringLiteral(value: String) extends LiteralValue {
    override def toString = s""""$value""""
  }

  abstract class Argument[T <: Location.HasLoc] extends Location.HasLoc {
    def loc: Location
  }

  case class PositionalArgument[T <: Location.HasLoc](expr: T) extends Argument[T] {
    override def toString = expr.toString

    def loc = expr.loc
  }

  case class NamedArgument[T <: Location.HasLoc](id: Identifier, expr: T) extends Argument[T] {
    override def toString = s"$id = $expr"

    def name = id.name

    def loc = id.loc.merge(expr.loc)
  }

  sealed abstract class Type extends Location.HasLoc {
    def loc: Location
  }

  case class SimpleType(id: Identifier) extends Type {
    def loc = id.loc

    override def toString = id.name
  }

  case class TypeApplication(id: Identifier, args: Seq[Type], loc: Location) extends Type {
    override def toString = s"$id[${args.mkString(", ")}]"
  }

  case class FunctionType(
    parameterTypes: Seq[(Option[TesslaAST.RuntimeEvaluation], Type)],
    returnType: Type,
    loc: Location
  ) extends Type {
    override def toString = s"(${parameterTypes.mkString(", ")}) => $returnType]"
  }

  case class ObjectType(memberTypes: Map[Identifier, Type], loc: Location) extends Type {
    override def toString = {
      val members = memberTypes.toSeq.map { case (name, t) => s"$name : $t" }
      members.mkString("{", ", ", "}")
    }
  }

  val unaryOperators = Map(
    "!" -> "not",
    "-" -> "negate",
    "-." -> "fnegate",
    "~" -> "bitflip"
  )

  val binaryOperators = Map(
    "&&" -> "and",
    "||" -> "or",
    "==" -> "eq",
    "!=" -> "neq",
    ">" -> "gt",
    "<" -> "lt",
    ">=" -> "geq",
    "<=" -> "leq",
    ">." -> "fgt",
    "<." -> "flt",
    ">=." -> "fgeq",
    "<=." -> "fleq",
    "+" -> "add",
    "-" -> "sub",
    "*" -> "mul",
    "/" -> "div",
    "%" -> "mod",
    "&" -> "bitand",
    "|" -> "bitor",
    "^" -> "bitxor",
    "<<" -> "leftshift",
    ">>" -> "rightshift",
    "+." -> "fadd",
    "-." -> "fsub",
    "*." -> "fmul",
    "/." -> "fdiv"
  )
}
