## For every function defined in the operator module
## there exists a special operator syntax which can be used
## to call the function using an infix operator.
module Operators {
  ## **Operator usage:** `!x`
  ##
  ## Boolean complement
  liftable def not(arg: strict Bool): Bool = extern("not")

  ## **Operator usage:** `if c then a else b`
  ##
  ## If-Then-Else
  liftable def ite[T](cond: strict Bool, thenCase: lazy T, elseCase: lazy T): T = extern("ite")

  ## **Operator usage:** `static if c then a else b`
  ##
  ## static If-Then-Else
  def staticite[T](cond: strict Bool, thenCase: lazy Events[T], elseCase: lazy Events[T]): Events[T] = extern("staticite")

  ## **Operator usage:** `a && b`
  ##
  ## Boolean conjunction
  liftable def and(lhs: lazy Bool, rhs: lazy Bool): Bool = extern("and")

  ## **Operator usage:** `a || b`
  ##
  ## Boolean disjunction
  liftable def or(lhs: lazy Bool, rhs: lazy Bool): Bool = extern("or")

  ## **Operator usage:** `a == b`
  ##
  ## Equivalence on arbitrary data types. On complex data structures this operator checks the object's identity. Note,
  ## that this operator is defined as `liftable`, so it does neither check the equivalence nor the identity of streams,
  ## but applies the operator on two streams using the signal semantics.
  liftable def eq[T](lhs: strict T, rhs: strict T): Bool = extern("eq")

  ## **Operator usage:** `a != b`
  ##
  ## Non-Equivalence on arbitrary data types. On complex data structures this operator checks the object's identity. Note,
  ## that this operator is defined as `liftable`, so it does neither check the equivalence nor the identity of streams,
  ## but applies the operator on two streams using the signal semantics.
  liftable def neq[T](lhs: strict T, rhs: strict T): Bool = extern("neq")

  ## **Operator usage:** `a > b`
  ##
  ## Returns @[Types#true] if `a` is strictly greater than `b`
  liftable def gt(lhs: strict Int, rhs: strict Int): Bool = extern("gt")

  ## **Operator usage:** `a < b`
  ##
  ## Returns @[Types#true] if `a` is strictly lower than `b`
  liftable def lt(lhs: strict Int, rhs: strict Int): Bool = extern("lt")

  ## **Operator usage:** `a >= b`
  ##
  ## Returns @[Types#true] if `a` is greater than or equal to `b`
  liftable def geq(lhs: strict Int, rhs: strict Int): Bool = extern("geq")

  ## **Operator usage:** `a <= b`
  ##
  ## Returns @[Types#true] if `a` is lower than or equal to `b`
  liftable def leq(lhs: strict Int, rhs: strict Int): Bool = extern("leq")

  ## **Operator usage:** `a >. b`
  ##
  ## Returns @[Types#true] if `a` is strictly greater than `b`
  liftable def fgt(lhs: strict Float, rhs: strict Float): Bool = extern("fgt")

  ## **Operator usage:** `a <. b`
  ##
  ## Returns @[Types#true] if `a` is strictly lower than `b`
  liftable def flt(lhs: strict Float, rhs: strict Float): Bool = extern("flt")

  ## **Operator usage:** `a >=. b`
  ##
  ## Returns @[Types#true] if `a` is greater than or equal to `b`
  liftable def fgeq(lhs: strict Float, rhs: strict Float): Bool = extern("fgeq")

  ## **Operator usage:** `a <=. b`
  ##
  ## Returns @[Types#true] if `a` is lower than or equal to `b`
  liftable def fleq(lhs: strict Float, rhs: strict Float): Bool = extern("fleq")

  ## **Operator usage:** `a + b`
  ##
  ## Returns the sum of two integers
  liftable def add(lhs: strict Int, rhs: strict Int): Int = extern("add")

  ## **Operator usage:** `a - b`
  ##
  ## Returns the difference of two integers
  liftable def sub(lhs: strict Int, rhs: strict Int): Int = extern("sub")

  ## **Operator usage:** `a * b`
  ##
  ## Returns the multiplication of two integers
  liftable def mul(lhs: strict Int, rhs: strict Int): Int = extern("mul")

  ## **Operator usage:** `a / b`
  ##
  ## Returns the division of two integers
  liftable def div(lhs: strict Int, rhs: strict Int): Int = extern("div")

  ## **Operator usage:** `a % b`
  ##
  ## Returns the remainder of two integers
  liftable def mod(lhs: strict Int, rhs: strict Int): Int = extern("mod")

  ## **Operator usage:** `-a`
  ##
  ## Unary minus on integers
  liftable def negate(arg: strict Int): Int = extern("negate")

  ## **Operator usage:** `a & b`
  ##
  ## Bitwise AND on integers
  liftable def bitand(lhs: strict Int, rhs: strict Int): Int = extern("bitand")

  ## **Operator usage:** `a | b`
  ##
  ## Bitwise OR on integers
  liftable def bitor(lhs: strict Int, rhs: strict Int): Int = extern("bitor")

  ## **Operator usage:** `a ^ b`
  ##
  ## Bitwise XOR on integers
  liftable def bitxor(lhs: strict Int, rhs: strict Int): Int = extern("bitxor")

  ## **Operator usage:** `~a`
  ##
  ## Bitflip on integers
  liftable def bitflip(arg: strict Int): Int = extern("bitflip")

  ## **Operator usage:** `a << b`
  ##
  ## Arithmetic left shift on integers
  liftable def leftshift(lhs: strict Int, rhs: strict Int): Int = extern("leftshift")

  ## **Operator usage:** `a >> b`
  ##
  ## Arithmetic right shift on integers
  liftable def rightshift(lhs: strict Int, rhs: strict Int): Int = extern("rightshift")

  ## **Operator usage:** `a +. b`
  ##
  ## Returns the sum of two floats
  liftable def fadd(lhs: strict Float, rhs: strict Float): Float = extern("fadd")

  ## **Operator usage:** `a -. b`
  ##
  ## Returns the difference of two floats
  liftable def fsub(lhs: strict Float, rhs: strict Float): Float = extern("fsub")

  ## **Operator usage:** `a *. b`
  ##
  ## Returns the multiplication of two floats
  liftable def fmul(lhs: strict Float, rhs: strict Float): Float = extern("fmul")

  ## **Operator usage:** `a /. b`
  ##
  ## Returns the division of two floats
  liftable def fdiv(lhs: strict Float, rhs: strict Float): Float = extern("fdiv")

  ## **Operator usage:** `-.a`
  ##
  ## Unary minus on floats
  liftable def fnegate(arg: strict Float): Float = extern("fnegate")
}
